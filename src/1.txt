è¡¨æ ¼æŸ¥è¯¢åŠŸèƒ½
<a-config-provider :getPopupContainer="getPopupContainer">
    <ThemeProvider is-root v-bind="themeConfig" :apply-style="false">
      <stepin-view
        system-name="Stepin"
        logo-src="@/assets/vite.svg"
        :class="`${contentClass}`"
        :user="user"
        :navMode="navigation"
        :useTabs="useTabs"
        :themeList="themeList"
        v-model:show-setting="showSetting"
        v-model:theme="theme"
        @themeSelect="configTheme"
      >
      </stepin-view>
    </ThemeProvider>
  </a-config-provider>
  <login-modal :unless="['/login']" />



  import { reactive, ref } from 'vue';
import { useRouter } from 'vue-router';
import { useAccountStore, useMenuStore, useSettingStore, storeToRefs } from '@/store';
import avatar from '@/assets/avatar.png';
import { PageFooter, HeaderActions } from '@/components/layout';
import Setting from './components/setting';
import { LoginModal } from '@/pages/login';
import { configTheme, themeList } from '@/theme';
import { ThemeProvider } from 'stepin';
import { computed } from 'vue';

const { logout, profile } = useAccountStore();

// è·å–ä¸ªäººä¿¡æ¯
profile().then((response) => {
  const { account } = response;
  user.name = account.username;
  // user.avatar = account.avatar;
});

const showSetting = ref(false);
const router = useRouter();

useMenuStore().getMenuList();

const { navigation, useTabs, theme, contentClass } = storeToRefs(useSettingStore());
const themeConfig = computed(() => themeList.find((item) => item.key === theme.value)?.config ?? {});

const user = reactive({
  name: 'admin',
  avatar: avatar,
  menuList: [
    { title: 'ä¸ªäººä¸­å¿ƒ', key: 'personal', icon: 'UserOutlined', onClick: () => router.push('/profile') },
    { title: 'è®¾ç½®', key: 'setting', icon: 'SettingOutlined', onClick: () => (showSetting.value = true) },
    { type: 'divider' },
    {
      title: 'é€€å‡ºç™»å½•',
      key: 'logout',
      icon: 'LogoutOutlined',
      onClick: () => logout().then(() => router.push('/login')),
    },
  ],
});

function getPopupContainer() {
  return document.querySelector('.stepin-layout');
}



 "dayjs": "^1.11.7",
    "element-plus": "^2.2.28",
    "everright-filter": "^1.1.1", 
    "jss": "^10.9.2",
    "jss-preset-default": "^10.9.2",
    "lodash": "^4.17.21",
    "nanoid": "^4.0.0",
    "nzh": "^1.0.8",
    "signature_pad": "^4.1.4",
    "vant": "^4.0.8",
    "vite-svg-loader": "^4.0.0",
    "vuedraggable": "^4.1.0"
     "@vant/area-data": "^1.4.0",
    "@vant/touch-emulator": "^1.4.0",
    "@vue/shared": "^3.2.45",
    "@vuelidate/core": "^2.0.0",
    "@vuelidate/validators": "^2.0.0",
    "async": "^3.2.4",
    "axios": "^1.2.2",
    "canvas": "^2.11.2"


    class ControlInsertion {
    sortable:any
    constructor(sortable) {
      this.sortable = sortable;
    }
    dragStart(e) {
      // å¤„ç†æ‹–æ‹½å¼€å§‹é€»è¾‘
    }

    drop(e) {
      if (!prevEl || !e.activeSortable) {
        return false;
      }
      const isBlock = _.get(e, 'activeSortable.options.dataSource', false) === 'block';
      const { dragEl, target } = e;
      const oldEl = getDragElement(dragEl);
      const newElement = ER.wrapElement(_.cloneDeep(oldEl), inserRowIndex !== '', true, isBlock);

      if (!isBlock && oldEl.context) {
        oldEl.context.delete();
      }

      if (inserRowIndex !== '') {
        let store = [];
        if (prevSortable.options.parent.type === 'subform') {
          store = prevSortable.options.parent.list[0];
        } else {
          store = Array.isArray(prevSortable.options.parent)
            ? prevSortable.options.parent
            : prevSortable.options.parent.list;
        }
        store.splice(inserRowIndex, 0, newElement);
        utils.addContext(store[inserRowIndex], prevSortable.options.parent);
      }

      if (inserColIndex !== '') {
        const { list } = prevSortable.el.__draggable_component__;
        list.splice(inserColIndex, 0, newElement);
        //@ts-ignore
        utils.addContext(newElement, prevSortable.options.parent[sortableUtils.index(prevSortable.el.parentNode)]);
      }

      if (inserColIndex !== '' || inserRowIndex !== '') {
        utils.deepTraversal(newElement, (node) => {
          if (utils.checkIsField(node)) {
            ER.addField(node);
          }
        });
        nextTick(() => {
          ER.setSelection(newElement);
        });
      }
      this.resetStates();
    }

    dragOver(e) {
      e.cancel();
      this.resetStates();
      const {
        activeSortable: {
          constructor: {
            utils: SortableUtils
          },
          options: {
            dataSource
          },
          el: {
            __draggable_component__: {
              list
            }
          } 
        }, 
        activeSortable,
        target,
        originalEvent,
        dragEl,
        sortable
      } = e;

      if (sortable.options.dataSource === 'block' || target.dataset.layoutType === 'grid') {
        return false;
      }

      const dragNode = getDragElement(dragEl);
      const targetNode = getDragElement(target);
      if ((!utils.checkIsField(dragNode) || dragNode.type === 'subform') && utils.checkIsInSubform(targetNode)) {
        return false;
      }
      if (target.dataset.layoutType === 'subform' && (!utils.checkIsField(dragNode) || dragNode.type === 'subform')) {
        return false;
      }

      originalEvent.stopPropagation && originalEvent.stopPropagation();
      //@ts-ignore
      let newTarget = SortableUtils.closest(target, this.sortable.options.draggable, sortable.el);
      if (dragEl.contains(newTarget)) {
        return false;
      }

      if (/^(grid-col|tabs-col|td|collapse-col|root|inline|subform)$/.test(target.dataset.layoutType)) {
        newTarget = target;
        const state = newTarget.__draggable_component__ || newTarget.children[0].__draggable_component__;
        if (!state.list.length) {
          prevEl = target.dataset.layoutType === 'root' ? target : (newTarget.__draggable_component__ ? newTarget.children[0] : newTarget.parentNode);
          prevSortable = state._sortable;
          inserRowIndex = 0;
          setBorder(prevEl, 'drag-line-top');
        } else {
          if (/^(root|grid-col)$/.test(target.dataset.layoutType)) {
            prevEl = lastChild(sortable.el);
            if (prevEl === dragEl.parentNode.parentNode && list.length === 1) {
              prevEl = '';
              return false;
            }
            setBorder(prevEl, 'drag-line-bottom');
            inserRowIndex = sortable.el.children.length;
            prevSortable = state._sortable;
          }
          if (target.dataset.layoutType === 'inline' && !disableBothSides(ER)) {

            prevEl = lastChild(sortable.el);
            if (prevEl.contains(dragEl) && list.length === 1) {
              prevEl = '';
              return false;
            }
            inserColIndex = sortable.el.children.length;
            prevSortable = state._sortable;
            setBorder(prevEl, 'drag-line-right');
          }
        }
      } else {
        this.setStates(newTarget, e, ER);
      }
    }

    resetStates() {
      prevEl = null;
      prevSortable = null;
      inserRowIndex = '';
      inserColIndex = '';
    }

    setStates(newTarget, e, ER) {
      // å¤„ç†æ’å…¥çŠ¶æ€çš„é€»è¾‘
    }
  }
  return Object.assign(ControlInsertion, {
    pluginName: 'ControlInsertion',
    initializeByDefault: true
  });












  function ControlInsertion (sortable) {
  }
  ControlInsertion.prototype = {
    dragStart (e) {
    },
    drop (e) {
      if (!prevEl || !e.activeSortable) {
        return false
      }
      const isBlock = _.get(e, 'activeSortable.options.dataSource', false) === 'block'
      const {
        dragEl,
        target
      } = e
      const oldEl = getDragElement(dragEl)
      const newElement = ER.wrapElement(_.cloneDeep(oldEl), inserRowIndex !== '', true, isBlock)
      if (!isBlock) {
        if (oldEl.context) {
          oldEl.context.delete()
          // utils.deepTraversal(oldEl, (node) => {
          //   if (utils.checkIsField(node) && node.type !== 'subform') {
          //     ER.delField(node)
          //   }
          // })
        }
      }
      if (inserRowIndex !== '') {
        let store = []
        if (prevSortable.options.parent.type === 'subform') {
          store = prevSortable.options.parent.list[0]
        } else {
          store = Array.isArray(prevSortable.options.parent) ? prevSortable.options.parent : prevSortable.options.parent.list
        }
        store.splice(inserRowIndex, 0, newElement)
        utils.addContext(store[inserRowIndex], prevSortable.options.parent)
      }
      if (inserColIndex !== '') {
        const {
          el: {
            __draggable_component__: {
              list
            }
          },
          el,
          constructor: {
            utils: sortableUtils
          }
        } = prevSortable
        list.splice(inserColIndex, 0, newElement)
        utils.addContext(newElement, prevSortable.options.parent[sortableUtils.index(prevSortable.el.parentNode)])
      }
      if (inserColIndex !== '' || inserRowIndex !== '') {
        utils.deepTraversal(newElement, (node) => {
          if (utils.checkIsField(node)) {
            ER.addField(node)
          }
        })
        nextTick(() => {
          ER.setSelection(newElement)
        })
      }
      resetStates()
    },
    dragOver (e) {
      // e.originalEvent && e.originalEvent.stopPropagation()
      e.cancel()
      resetStates()
      const {
        activeSortable: {
          constructor: {
            utils: SortableUtils
          },
          options: {
            dataSource
          },
          el: {
            __draggable_component__: {
              list
            }
          }
        },
        activeSortable,
        target,
        originalEvent,
        dragEl,
        sortable: {
          el,
          el: {
            __draggable_component__: {
              list: targetList
            }
          }
        },
        sortable
      } = e
      if (sortable.options.dataSource === 'block') {
        return false
      }
      if (target.dataset.layoutType === 'grid') {
        return false
      }
      const dragNode = getDragElement(dragEl)
      const targetNode = getDragElement(target)
      if ((!utils.checkIsField(dragNode) || dragNode.type === 'subform') && utils.checkIsInSubform(targetNode)) {
        return false
      }
      if (target.dataset.layoutType === 'subform') {
        // console.log(utils)
        if (!utils.checkIsField(dragNode) || dragNode.type === 'subform') {
          return false
        }
      }
      originalEvent.stopPropagation && originalEvent.stopPropagation()
      const direction = ''
      const targetContainer = el.parentNode
      const targetOnlyOne = targetList.length === 1
      let newTarget = SortableUtils.closest(target, this.options.draggable, sortable.el)
      if (dragEl.contains(newTarget)) {
        return false
      }
      if (/^(grid-col|tabs-col|td|collapse-col|root|inline|subform)$/.test(target.dataset.layoutType)) {
        newTarget = target
        const state = (newTarget.__draggable_component__ || newTarget.children[0].__draggable_component__)
        if (!state.list.length) {
          prevEl = target.dataset.layoutType === 'root' ? target : newTarget.__draggable_component__ ? newTarget.children[0] : newTarget.parentNode
          prevSortable = state._sortable
          inserRowIndex = 0
          setBorder(prevEl, 'drag-line-top')
        } else {
          if (/^(root|grid-col)$/.test(target.dataset.layoutType)) {
            const rows = el.children
            prevEl = lastChild(el)
            if (prevEl === dragEl.parentNode.parentNode && list.length === 1) {
              prevEl = ''
              return false
            }
            setBorder(prevEl, 'drag-line-bottom')
            inserRowIndex = rows.length
            prevSortable = state._sortable
          }
          if (target.dataset.layoutType === 'inline') {
            if (disableBothSides(ER)) return false
            const cols = el.children
            prevEl = lastChild(el)
            if (prevEl.contains(dragEl) && list.length === 1) {
              prevEl = ''
              return false
            }
            inserColIndex = cols.length
            prevSortable = state._sortable
            setBorder(prevEl, 'drag-line-right')
          }
        }
      } else {
        setStates(newTarget, e, ER)
      }
    }
  }
  return Object.assign(ControlInsertion, {
    pluginName: 'ControlInsertion',
    initializeByDefault: true
  })



  import { defineComponent, ref, unref, inject, PropType } from 'vue';
import { ElButton } from 'element-plus';
import { Button as VanButton } from 'vant';
import hooks from '@ER/hooks';

export default defineComponent({
  name: 'ErCompleteButton',
  props: {
    handle: Object as PropType<{ validate: () => Promise<void> }>,
    mode: {
      type: String as PropType<'edit' | 'preview'>,
      default: 'edit',
    },
  },
  setup(props) {
    const ER = inject('Everright') as any;
    const ns = hooks.useNamespace('CompleteButton');
    const { state, isPc } = hooks.useTarget();
    const element = ref<string | null>(null);

    const handleClick = async () => {
      if (props.mode === 'preview') return;
      try {
        await Promise.resolve(unref(props.handle)?.validate());
        ER.fireEvent('submit', ER.getData());
      } catch (e) {
        console.error(e);
      }
    };

    const dataset = process.env.NODE_ENV === 'test' ? { 'data-test': 'er-complete-button' } : {};

    return () => (
      <div {...dataset}>
        {isPc.value ? (
          <div style="text-align: center;">
            <ElButton
              onClick={handleClick}
              type="primary"
              style={{ backgroundColor: state.value.config[state.value.platform].completeButton.backgroundColor }}
            >
              <span style={{ color: state.value.config[state.value.platform].completeButton.color }}>
                {state.value.config[state.value.platform].completeButton.text}
              </span>
            </ElButton>
          </div>
        ) : (
          <VanButton
            onClick={handleClick}
            round
            block
            type="primary"
            style={{ backgroundColor: state.value.config[state.value.platform].completeButton.backgroundColor }}
          >
            <span style={{ color: state.value.config[state.value.platform].completeButton.color }}>
              {state.value.config[state.value.platform].completeButton.text}
            </span>
          </VanButton>
        )}
      </div>
    );
  },
});


 // const handleAction = (type) => {
    //   const index = type !== 5 && props.parent.indexOf(props.data);
    //   switch (type) {
    //     case 1:
    //       if (ER.props.delHandle(props.data) === false) return false;
    //       props.data.context.delete();
    //       utils.deepTraversal(props.data, (node) => {
    //         if (utils.checkIsField(node)) {
    //           ER.delField(node);
    //         }
    //       });
    //       if (/^(radio|checkbox|select)$/.test(props.data.type)) {
    //         delete state.data[props.data.options.dataKey];
    //       }
    //       if (props.parent.length > 0) {
    //         if (index === props.parent.length) {
    //           setSelection(props.parent[index - 1]);
    //         } else {
    //           setSelection(props.parent[index]);
    //         }
    //       } else {
    //         setSelection('root');
    //       }
    //       break;
    //     case 2:
    //       if (ER.props.copyHandle(props.data) === false) return false;
    //       props.data.context.copy();
    //       const copyData = props.parent[index + 1];
    //       setSelection(copyData);
    //       utils.deepTraversal(copyData, (node) => {
    //         ER.addFieldData(node, true);
    //         if (utils.checkIsField(node)) {
    //           ER.addField(node);
    //         }
    //       });
    //       break;
    //     case 3:
    //       //@ts-ignore
    //       _.last(props.data.context.columns[0]).context.insert('bottom');
    //       break;
    //     case 4:
    //       //@ts-ignore
    //       _.last(props.data.context.columns)[0].context.insert('right');
    //       break;
    //     case 5:
    //       let parent = props.data.context.parent;
    //       if (/^(inline|tr)$/.test(parent.type)) {
    //         parent = parent.context.parent;
    //       }
    //       setSelection(Array.isArray(parent) ? 'root' : parent);
    //       break;
    //     case 6:
    //       props.data.context.appendCol();
    //       break;
    //   }
    // };



    // export const addContext = (node, parent?: any, fn?: any) => {
//   let arr = []
//   const isArray = Array.isArray(parent)
//   if (isArray) {
//     arr = parent
//   } else {
//     arr = parent.columns || parent.list || parent.rows
//   }
//   fn && fn(node) 
//   const context = {
//     get props() {
//       return (isPc) => computed(() => {
//         const {
//           options
//         } = node
//         const result: any = {
//           disabled: options.disabled,
//           placeholder: options.placeholder,
//           clearable: options.clearable,
//           required: options.required
//         }
//         if (isPc) {
//           // result.style = {
//           //   width: options.width + options.widthType
//           // }
//         } else {
//           result.label = node.label
//         }
//         switch (node.type) {
//           case 'input':
//             if (options.isShowWordLimit) {
//               result.maxlength = options.max
//               result['show-word-limit'] = options.isShowWordLimit
//             }
//             if (isPc) {
//               result.showPassword = options.showPassword
//               result.prepend = options.prepend
//               result.append = options.append
//             } else {
//               if (options.showPassword) {
//                 result.type = 'password'
//               }
//               if (options.renderType === 4) {
//                 result.type = 'tel'
//               }
//             }
//             break
//           case 'textarea':
//             result.type = 'textarea'
//             result.rows = options.rows
//             break
//           case 'number':
//             if (isPc) {
//               result.controls = options.controls
//               if (options.controls) {
//                 result['controls-position'] = options.controlsPosition ? 'right' : ''
//               }
//             }
//             if (options.isShowWordLimit) {
//               result.min = options.min
//               result.max = options.max
//             }
//             result.step = options.step
//             result.precision = options.precision
//             break
//           case 'radio':
//           case 'checkbox':
//             break
//           case 'select':
//             break
//           case 'time':
//             result.format = options.format
//             if (isPc) {
//               result.valueFormat = options.valueFormat
//             }
//             break
//           case 'date':
//             result.placeholder = options.placeholder
//             result.startPlaceholder = options.startPlaceholder
//             result.endPlaceholder = options.endPlaceholder
//             result.format = options.format
//             result.type = options.type
//             if (isPc) {
//               result.disabledDate = (time) => {
//                 const {
//                   startTime,
//                   endTime,
//                   weeks,
//                   isShowWeeksLimit
//                 } = options
//                 const startDate = dayjs.unix(startTime)
//                 const endDate = dayjs.unix(endTime)
//                 const currentDate = dayjs(time)
//                 const result = currentDate.isBefore(startDate) || currentDate.isAfter(endDate)
//                 return result
//               }
//             } else {
//               const {
//                 startTime,
//                 endTime,
//                 weeks,
//                 isShowWeeksLimit
//               } = options
//               switch (options.type) {
//                 case 'date':
//                 case 'datetime':
//                   if (startTime) {
//                     result.minDate = dayjs.unix(startTime).toDate()
//                   } else {
//                     result.minDate = dayjs.unix(0).toDate()
//                   }
//                   if (endTime) {
//                     result.maxDate = dayjs.unix(endTime).toDate()
//                   } else {
//                     result.maxDate = dayjs().add(20, 'year').toDate()
//                   }
//                   break
//                 case 'dates':
//                   if (options.defaultValue) {
//                     result.defaultDate = options.defaultValue.map(e => dayjs.unix(e).toDate())
//                   } else {
//                     result.defaultDate = null
//                   }
//                   if (startTime) {
//                     result.minDate = dayjs.unix(startTime).toDate()
//                   } else {
//                     result.minDate = dayjs().subtract(1, 'year').toDate()
//                   }
//                   if (endTime) {
//                     result.maxDate = dayjs.unix(endTime).toDate()
//                   } else {
//                     result.maxDate = dayjs().add(1, 'year').toDate()
//                   }
//                   break
//                 case 'daterange':
//                   if (options.defaultValue) {
//                     result.defaultDate = options.defaultValue.map(e => dayjs.unix(e).toDate())
//                   } else {
//                     result.defaultDate = null
//                   }
//                   if (startTime) {
//                     result.minDate = dayjs.unix(startTime).toDate()
//                   } else {
//                     result.minDate = dayjs().subtract(1, 'year').toDate()
//                   }
//                   if (endTime) {
//                     result.maxDate = dayjs.unix(endTime).toDate()
//                   } else {
//                     result.maxDate = dayjs().add(1, 'year').toDate()
//                   }
//                   break
//               }
//             }
//             break
//           case 'cascader':
//             result.props = {
//               multiple: options.multiple,
//               checkStrictly: options.checkStrictly
//             }
//             result.options = options.options
//             break
//           case 'slider':
//             result.step = options.step
//             result.min = options.min
//             result.max = options.max
//             break
//           case 'divider':
//             result.contentPosition = options.contentPosition
//             break
//           case 'uploadfile':
//             result.multiple = options.multiple
//             result.action = options.action
//             result.limit = options.limit
//             result.size = options.size
//             result.accept = options.accept
//             break
//         }
//         return result
//       })
//     },
//     get row() {
//       let result: any = ''
//       if (isArray || node.type === 'tr') {
//         result = arr.indexOf(node)
//       } else {
//         result = parent.context.row
//       }
//       return result
//     },
//     get col() {
//       let result: any = ''
//       if (isArray) {
//         result = 0
//       } else {
//         if (parent.type === 'grid' || parent.type === 'tr' || parent.type === 'td' || parent.type === 'col' || parent.type === 'tabsCol' || parent.type === 'collapseCol') {
//           result = arr.indexOf(node)
//         } else {
//           result = parent.context.col
//         }
//       }
//       return result
//     },
//     get root() {
//       let result = {}
//       switch (node.type) {
//         case 'grid':
//         case 'table':
//           result = node
//           break
//         default:
//           result = parent.context.root
//       }
//       return result
//     },
//     state: node,
//     parent,
//     get parents() {
//       const result = []
//       let cursor = node
//       while (cursor) {
//         result.unshift(cursor)
//         if (cursor.context.parent && !_.isArray(cursor.context.parent)) {
//           cursor = cursor.context.parent
//         } else {
//           cursor = ''
//         }
//       }
//       return result
//     },
//     copy() {
//       const index = arr.indexOf(node)
//       const newNode = reactive(_.cloneDeep(toRaw(node)))
//       delete newNode.context
//       newNode.id = nanoid()
//       newNode.key = `${newNode.type}_${newNode.id}`
//       addContext(newNode, parent, (node) => {
//         node.id = nanoid()
//         node.key = `${node.type}_${node.id}-copy`
//       })
//       arr.splice(index + 1, 0, newNode)
//     },
//     delete() {
//       if (utils.checkIsInSubform(node) && node.type === 'inline') {
//         arr[0].splice(arr[0].indexOf(node), 1)
//       } else {
//         arr.splice(arr.indexOf(node), 1)
//       }
//     },
//     appendCol() {
//       const newNode = wrapElement({
//         options: {
//           span: 6,
//           offset: 0,
//           pull: 0,
//           push: 0
//         },
//         type: 'col',
//         list: [
//         ]
//       })
//       node.columns.push(newNode)
//       addContext(newNode, node)
//     },
//     get columns() {
//       const result = []
//       switch (node.type) {
//         case 'table':
//           node.rows.forEach((item0, index0) => {
//             item0.columns.forEach((item1, index1) => {
//               if (!index0) {
//                 result.push([])
//               }
//               result[index1].push(item1)
//             })
//           })
//           break
//         default:
//       }
//       return result
//     },
//     get isDisableMargeLeft() {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const nodes = root.rows[row].columns
//       let result = col <= 0
//       if (!result) {
//         let onOff = true
//         findNode(node, 'before', 'colspan', (nodes) => {
//           onOff = result = !nodes.every(e => e.options.rowspan === node.options.rowspan) || nodes.every(e => e.options.isMerged)
//         })
//         result = onOff
//       }
//       return result
//     },
//     get isDisableMargeRight() {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const nodes = root.rows[row].columns
//       let result = col >= nodes.length - 1
//       if (!result) {
//         let onOff = true
//         findNode(node, 'after', 'colspan', (nodes) => {
//           onOff = result = !nodes.every(e => e.options.rowspan === node.options.rowspan) || nodes.every(e => e.options.isMerged)
//         })
//         result = onOff
//       }
//       return result
//     },
//     get isDisableMargeRow() {
//       const nodes = getNodes(node, 'colspan')
//       return this.isDisableDelRow || nodes.length === node.options.colspan
//     },
//     get isDisableMargeColumn() {
//       const nodes = getNodes(node, 'rowspan')
//       return this.isDisableDelColumn || nodes.length === node.options.rowspan
//     },
//     get isDisableMargeBottom() {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const columns = root.context.columns
//       let result = row >= columns[col].length - 1
//       if (!result) {
//         let onOff = true
//         findNode(node, 'after', 'rowspan', (nodes) => {
//           onOff = result = !nodes.every(e => e.options.colspan === node.options.colspan) || nodes.every(e => e.options.isMerged)
//         })
//         result = onOff
//       }
//       return result
//     },
//     get isDisableMargeTop() {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const columns = root.context.columns
//       let result = row <= 0
//       if (!result) {
//         let onOff = true
//         findNode(node, 'before', 'rowspan', (nodes) => {
//           onOff = result = !nodes.every(e => e.options.colspan === node.options.colspan) || nodes.every(e => e.options.isMerged)
//         })
//         result = onOff
//       }
//       return result
//     },
//     get isDisableSplitColumn() {
//       return node.options.colspan === 1
//     },
//     get isDisableSplitRow() {
//       return node.options.rowspan === 1
//     },
//     get isDisableDelRow() {
//       const nodes = getNodes(node, 'colspan')
//       const rowspanNodes = getNodes(node, 'rowspan')
//       return (rowspanNodes.length === 1 || rowspanNodes.filter(e => !e.options.isMerged).length === 1) || !nodes.every(e => e.options.rowspan === node.options.rowspan)
//     },
//     get isDisableDelColumn() {
//       const nodes = getNodes(node, 'rowspan')
//       const colspanNodes = getNodes(node, 'colspan')
//       return (colspanNodes.length === 1 || colspanNodes.filter(e => !e.options.isMerged).length === 1) || !nodes.every(e => e.options.colspan === node.options.colspan)
//     },
//     merge(type) {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       switch (type) {
//         case 'left':
//           findNode(node, 'before', 'colspan', (nodes, callBack) => {
//             callBack()
//           })
//           break
//         case 'right':
//           findNode(node, 'after', 'colspan', (nodes, callBack) => {
//             callBack()
//           })
//           break
//         case 'top':
//           findNode(node, 'before', 'rowspan', (nodes, callBack) => {
//             callBack()
//           })
//           break
//         case 'bottom':
//           findNode(node, 'after', 'rowspan', (nodes, callBack) => {
//             callBack()
//           })
//           break
//         case 'row':
//           while (root.rows[row].columns.length > root.rows[row].columns[0].options.colspan) {
//             findNode(root.rows[row].columns[0], 'after', 'colspan', (nodes, callBack) => {
//               callBack()
//             })
//           }
//           break
//         case 'column':
//           while (root.context.columns[col].length > root.context.columns[col][0].options.rowspan) {
//             findNode(root.context.columns[col][0], 'after', 'rowspan', (nodes, callBack) => {
//               callBack()
//             })
//           }
//           break
//         default:
//       }
//     },
//     insert(type) {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       switch (type) {
//         case 'left':
//           appendNodes(node, 'before', 'colspan')
//           // root.rows.forEach(e => {
//           //   addContext(e, root, false)
//           // })
//           break
//         case 'right':
//           appendNodes(node, 'after', 'colspan')
//           break
//         case 'top':
//           appendNodes(node, 'before', 'rowspan')
//           break
//         case 'bottom':
//           appendNodes(node, 'after', 'rowspan')
//           break
//       }
//     },
//     split(type) {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const nodes = getNodes(node, type === 'column' ? 'colspan' : 'rowspan')
//       switch (type) {
//         case 'column':
//           //  zheliyoudu  æ²¡æœ‰è€ƒè™‘åº•å±‚
//           nodes.slice(col, col + node.options.colspan).forEach(e => {
//             e.options.colspan = 1
//             e.options.isMerged = false
//             if (e.options.rowspan > 1) {
//               const nodes = getNodes(e, 'rowspan')
//               nodes.slice(row + 1, row + e.options.rowspan).forEach((e) => {
//                 e.options.colspan = 1
//               })
//             }
//           })
//           break
//         case 'row':
//           nodes.slice(row, row + node.options.rowspan).forEach(e => {
//             e.options.rowspan = 1
//             e.options.isMerged = false
//             if (e.options.colspan > 1) {
//               const nodes = getNodes(e, 'colspan')
//               nodes.slice(col + 1, col + e.options.colspan).forEach((e) => {
//                 e.options.rowspan = 1
//               })
//             }
//           })
//           break
//       }
//     },
//     del(type) {
//       const {
//         context: {
//           root,
//           col,
//           row
//         }
//       } = node
//       const nodes = getNodes(node, type === 'column' ? 'colspan' : 'rowspan')//
//       switch (type) {
//         case 'column':
//           root.rows.forEach(e => {
//             e.columns.splice(col, node.options.colspan)
//             addContext(e, root)
//           })
//           break
//         case 'row':
//           root.rows.splice(row, node.options.rowspan)
//           root.rows.forEach(e => {
//             addContext(e, root)
//           })
//           break
//       }
//     }
//   }

//   Object.defineProperty(node, 'context', {
//     value: context,
//     writable: false,
//     enumerable: false,
//     configurable: true
//   })
//   let nodes = []
//   if (node.type === 'subform') {
//     nodes = node.list[0]
//   } else {
//     nodes = node.columns || node.list || node.rows || []
//   }
//   nodes.forEach(e => {
//     addContext(e, node, fn)
//   })
// }


 return <el-aside class={[ns.b()]} width={ER.props.configPanelWidth}>
        <el-breadcrumb
          class={[ns.e('breadcrumb')]}
          separator-icon={() => (
            <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
              <path
                fill="currentColor"
                d="M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
              />
            </svg>
          )}
          {...utils.addTestId('configPanel:breadcrumb')}
        >
          {bars.value.map((item, index) => (
            <el-breadcrumb-item
              key={index}
              onClick={() => {
                if (index !== bars.value.length - 1 && item.node.value !== 'placeholder') {
                  handleBreadcrumbClick(item.node);
                }
              }}
            >
              {item.node.value === 'placeholder' ? '...' : item.label}
            </el-breadcrumb-item>
          ))}
        </el-breadcrumb>

        <el-form ref="form" model={target} rules={rules} label-width="120px" label-position="top">
          <el-scrollbar>
            <div class={[ns.e('wrap')]}>
              {isSelectAnyElement && <PanelsConfigComponentsPropsPanel key={target.id} />}
              {isSelectRoot && <GlobalConfigPanel />}
            </div>
          </el-scrollbar>
        </el-form>
      </el-aside>


<<<<<<< HEAD
       // case 'subform':
          //   if (unref(isEditModel) || _.get(state.fieldsLogicState.get(element), 'visible', undefined) !== 0) {
          //     node = (<LayoutSubformLayout key={element.id} data={element} parent={props.data}></LayoutSubformLayout>)
          //   }
          //   break




          // let form = this.form
        // let items = form.items
        // let curIndex = items.findIndex((item) => item === this)
        // if (curIndex === -1) {
        //     curIndex = items.length//
        // }
        // let preItems = items.slice(0, curIndex)
        // let preSpans = preItems.map((item) => item.getSpan())
        // let preSpan = preSpans.reduce((a, b) => a + b, 0)//
        // let rowIndex = Math.ceil((preSpan + this.getSpan()) / 24)
        // let rows = form.getLayoutRows()//
        // let length = rows.length
        // let tr: TableRow = null
        // if (length < rowIndex) {
        //     tr = this.createTrRow()
        //     form.addTrRow(tr)
        // } else {
        //     tr = rows.slice(-1).pop()
        // }
        // return tr
=======
      // drop(e) {
    //   if (!prevEl || !e.activeSortable) {
    //     return false
    //   }
    //   const isBlock = _.get(e, 'activeSortable.options.dataSource', false) === 'block'
    //   const {
    //     dragEl,
    //     target
    //   } = e
    //   const oldEl = getDragElement(dragEl)
    //   const newElement = ER.wrapElement(_.cloneDeep(oldEl), inserRowIndex !== '', true, isBlock)
    //   if (!isBlock) {
    //     if (oldEl.context) {
    //       oldEl.context.delete()
    //     }
    //   }
    //   if (inserRowIndex !== '') {
    //     let store = []
    //     if (prevSortable.options.parent.type === 'subform') {
    //       store = prevSortable.options.parent.list[0]
    //     } else {
    //       store = Array.isArray(prevSortable.options.parent) ? prevSortable.options.parent : prevSortable.options.parent.list
    //     }
    //     store.splice(inserRowIndex, 0, newElement)
    //     utils.addContext(store[inserRowIndex], prevSortable.options.parent)
    //   }
    //   if (inserColIndex !== '') {
    //     const {
    //       el: {
    //         __draggable_component__: {
    //           list
    //         }
    //       },
    //       el,
    //       constructor: {
    //         utils: sortableUtils
    //       }
    //     } = prevSortable
    //     list.splice(inserColIndex, 0, newElement)
    //     utils.addContext(newElement, prevSortable.options.parent[sortableUtils.index(prevSortable.el.parentNode)])
    //   }
    //   if (inserColIndex !== '' || inserRowIndex !== '') {
    //     utils.deepTraversal(newElement, (node) => {
    //       if (utils.checkIsField(node)) {
    //         ER.addField(node)
    //       }
    //     })
    //     nextTick(() => {
    //       ER.setSelection(newElement)
    //     })
    //   }
    //   resetStates()
    // }
>>>>>>> refs/remotes/origin/main


// const addValidate = (result, node, isPc, t, state, ExtraParams) => {
//   const {
//     options
//   } = node
//   if (isPc) {
//     result.prop = node.context && node.context.parents.map((e, index) => {
//       let result = ''
//       if (!index) {
//         result = e.context.parent.indexOf(e)
//       } else {
//         const parent = e.context.parent
//         let nodes = []
//         if (parent.type === 'subform') {
//           const {
//             x,
//             y
//           } = findPosition(e, parent)
//           result += `list.${y}.${x}`
//         } else {
//           if (parent.columns) {
//             nodes = parent.columns
//             result += 'columns.'
//           } else if (parent.list) {
//             nodes = parent.list
//             result += 'list.'
//           } else if (parent.rows) {
//             nodes = parent.rows
//             result += 'rows.'
//           }
//           result += nodes.indexOf(e)
//         }
//       }
//       return result
//     }).join('.') + '.options.defaultValue'
//   }

//   const obj: any = {
//   }
//   const validator = (...arg0) => new Promise((...arg1: any) => {
//     const resolve = () => {
//       arg1[0]()
//     }
//     const reject = isPc
//       ? arg1[1]
//       : (message) => {
//         obj.message = message
//         arg1[0](false)
//       }
//     let value = isPc ? arg0[1] : arg0[0]
//     if (/^(signature|radio|checkbox|select|html)$/.test(node.type)) {
//       value = options.defaultValue
//     }
//     const newValue = options.isShowTrim ? value.trim() : value
//     if (node.type === 'subform') {
//       const allFields = utils.findSubFormAllFields(node)
//       if (result.required) {
//         if (allFields.length) {
//           if (allFields.some(e => utils.isEmpty(e.options.isShowTrim ? e.options.defaultValue.trim() : e.options.defaultValue))) {
//             reject(t('er.validateMsg.required'))
//           }
//         } else {
//           reject(t('er.validateMsg.required'))
//         }
//       } else {
//         resolve()
//       }
//     } else {
//       let isRequired = result.required
//       if (state.mode === 'preview' && utils.checkIsInSubform(node)) {
//         const parent = node?.context?.parent?.context?.parent
//         if (parent) {
//           const {
//             readOnly,
//             required
//           } = getLogicStateByField(parent, state.fieldsLogicState)
//           const parentProps: any = useProps(state, parent, isPc, false, false, t, ExtraParams).value
//           if (required !== undefined) {
//             isRequired = parentProps.required
//           }
//         }
//       }
//       if (isRequired && node.type !== 'subform' && utils.isEmpty(newValue)) {
//         reject(t('er.validateMsg.required'))
//         return
//       }
//       if (/^(select|checkbox|radio)$/.test(node.type)) {
//         if ((_.isArray(node.options.defaultValue) ? node.options.defaultValue : [node.options.defaultValue]).includes('other')) {
//           const key = node.key + '_other'
//           if (!state.othersFiles[key]) {
//             reject(t('er.validateMsg.placeholder3'))
//             return false
//           }
//         }
//       }
//     }
//     switch (node.type) {
//       case 'input':
//         switch (options.renderType) {
//           case 1:
//             if (!!newValue && options.isShowWordLimit && newValue.length < options.min) {
//               reject(t('er.validateMsg.limitWord', { min: options.min }))
//             } else {
//               resolve()
//             }
//             break
//           case 2:
//             if (!!newValue && !/\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(newValue)) {
//               reject(t('er.validateMsg.email'))//
//             } else {
//               resolve()
//             }
//             break
//           case 3:
//             if (!!newValue && !/^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(newValue)) {
//               reject(t('er.validateMsg.IdNumber'))
//             } else {
//               resolve()
//             }
//             break
//           case 4:
//             if (!!newValue && !/^(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]{8}$/.test(newValue)) {
//               reject(t('er.validateMsg.phone'))
//             } else {
//               resolve()
//             }
//             break
//           case 5:
//             if (!!newValue && !/^https?:\/\/(([a-zA-Z0-9_-])+(\.)?)*(:\d+)?(\/((\.)?(\?)?=?&?[a-zA-Z0-9_-](\?)?)*)*$/i.test(newValue)) {
//               reject(t('er.validateMsg.http'))
//             } else {
//               resolve()
//             }
//             break
//         }
//         break
//       case 'textarea':
//         if (!!newValue && options.isShowWordLimit && newValue.length < options.min) {
//           reject(t('er.validateMsg.limitWord', { min: options.min }))
//         } else {
//           resolve()
//         }
//         break
//       default:
//         resolve()
//         break
//     }
//   })
//   if (isPc) {
//     obj.required = options.required
//     obj.asyncValidator = validator
//   } else {
//     obj.validator = validator
//   }
//   result.rules = [obj]
// }













<template>
    <div class="container">
        <h2 class="title">æ‹–æ‹½æ’åºç¤ºä¾‹</h2>
        <draggable v-model="items" group="list" @start="onStart" @end="onEnd" @change="onChange" item-key="id"
            class="list">
            <template #item="{ element }">
                <div class="list-item">{{ element.name }}</div>
            </template>
        </draggable> 
    </div>
</template>

<script>
import draggable from "@ER/vueDraggable/vuedraggable";

export default {
    components: { draggable },
    data() {
        return {
            items: [
                { id: 1, name: "è‹¹æœ ğŸ" },
                { id: 2, name: "é¦™è•‰ ğŸŒ" },
                { id: 3, name: "æ©™å­ ğŸŠ" },
                { id: 4, name: "è‘¡è„ ğŸ‡" }
            ]
        };
    },
    methods: {
        onStart(evt) {
            console.log("å¼€å§‹æ‹–æ‹½:", evt);
        },
        onEnd(evt) {
            console.log("æ‹–æ‹½ç»“æŸ:", evt);
        },
        onChange(evt) {
            console.log("åˆ—è¡¨å·²æ›´æ–°:", this.items);
        }
    }
};
</script>

<style>
.container {
    max-width: 400px;
    margin: auto;
    text-align: center;
}

.title {
    font-size: 20px;
    margin-bottom: 10px;
}

.list {
    border: 2px dashed #ccc;
    padding: 10px;
    border-radius: 8px;
}

.list-item {
    padding: 10px;
    margin: 5px 0;
    background: #f8f8f8;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: grab;
}
</style>








//åœ¨ä»£ç æ¼”ç¤ºä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•åœ¨è¡¨æ ¼ä¸­æ¸²æŸ“è‡ªå®šä¹‰çš„ Vue ç»„ä»¶ã€‚å…·ä½“åŒ…æ‹¬ï¼š
//- **æ€§åˆ«åˆ—**ï¼šé€šè¿‡ `ArcoDesignVue.Tag` ç»„ä»¶æ¥æ¸²æŸ“æ€§åˆ«ä¿¡æ¯ï¼Œå¹¶æ ¹æ®æ€§åˆ«å€¼åŠ¨æ€æ”¹å˜æ ‡ç­¾é¢œè‰²ã€‚
//- **è¯„è®ºåˆ—**ï¼šé€šè¿‡ `ArcoDesignVue.Comment` ç»„ä»¶æ¥æ¸²æŸ“è¯„è®ºä¿¡æ¯ï¼Œå¹¶åŒ…å«ç‚¹èµã€æ”¶è—ã€å›å¤ç­‰æ“ä½œæŒ‰é’®ã€‚

const app = createApp({
  template: `
    <vue-list-table :options="option" :records="records" ref="tableRef" />
  `,
  data() {
    return {
      tableRef: ref(null),
      option: {
        records: [
          { gender: 'ç”·', name: 'å¼ ä¸‰', age: 20, city: 'åŒ—äº¬' },
          { gender: 'å¥³', name: 'æå››', age: 21, city: 'ä¸Šæµ·' },
          { gender: 'ç”·', name: 'ç‹äº”', age: 22, city: 'å¹¿å·' },
          { gender: 'å¥³', name: 'èµµå…­', age: 23, city: 'æ·±åœ³' },
          { gender: 'ç”·', name: 'å­™ä¸ƒ', age: 24, city: 'æˆéƒ½' },
          { gender: 'å¥³', name: 'å‘¨å…«', age: 25, city: 'é‡åº†' },
          { gender: 'ç”·', name: 'å´ä¹', age: 26, city: 'è¥¿å®‰' }
        ],
        columns: [
          {
            field: 'name',
            title: 'å§“å',
            width: 200,
             headerCustomLayout: args => {
              const { table, row, col, rect, value } = args;
              const { height, width } = rect ?? table.getCellRect(col, row);

              const container = new VTable.CustomLayout.Group({
                height,
                width,
                display: 'flex',
                alignItems: 'center',
                vue: {
                  element: h(ArcoDesignVue.Tag, { color: 'green' }, value),
                  container: table.headerDomContainer
                }
              });
              return {
                rootContainer: container,
                renderDefault: false
              };
            },
            customLayout: args => {
              const { table, row, col, rect, value } = args;
              const { height, width } = rect ?? table.getCellRect(col, row);

              const container = new VTable.CustomLayout.Group({
                height,
                width,
                display: 'flex',
                alignItems: 'center',
                vue: {
                  element: h('div', { color: value === 'å¥³' ? 'magenta' : 'arcoblue' }, value),
                  container: table.bodyDomContainer
                }
              });

              return {
                rootContainer: container,
                renderDefault: false
              };
            }
          },
          { field: 'age', title: 'å¹´é¾„', width: 150 },
          { field: 'city', title: 'åŸå¸‚', width: 200 },
          {
            field: 'gender',
            title: 'æ€§åˆ«',
            width: 100,
            headerCustomLayout: args => {
              const { table, row, col, rect, value } = args;
              const { height, width } = rect ?? table.getCellRect(col, row);

              const container = new VTable.CustomLayout.Group({
                height,
                width,
                display: 'flex',
                alignItems: 'center',
                vue: {
                  element: h(ArcoDesignVue.Tag, { color: 'green' }, value),
                  container: table.headerDomContainer
                }
              });
              return {
                rootContainer: container,
                renderDefault: false
              };
            },
            customLayout: args => {
              const { table, row, col, rect, value } = args;
              const { height, width } = rect ?? table.getCellRect(col, row);

              const container = new VTable.CustomLayout.Group({
                height,
                width,
                display: 'flex',
                alignItems: 'center',
                vue: {
                  element: h('div', { color: value === 'å¥³' ? 'magenta' : 'arcoblue' }, value),
                  container: table.bodyDomContainer
                }
              });

              return {
                rootContainer: container,
                renderDefault: false
              };
            }
          },
          {
            field: 'comment',
            title: 'è¯„è®º',
            width: 300,
            customLayout: args => {
              const { table, row, col, rect, value } = args;
              const { height, width } = rect ?? table.getCellRect(col, row);

              const container = new VTable.CustomLayout.Group({
                height,
                width,
                display: 'flex',
                alignItems: 'center',
                vue: {
                  element: h(
                    ArcoDesignVue.Comment,
                    { author: 'Socrates', content: value, datetime: '1 hour' },
                    {
                      actions: () => [
                        h('span', { key: 'heart', style: { cursor: 'pointer' } }, [h('span', 'Like')]),
                        h('span', { key: 'star', style: { cursor: 'pointer' } }, [h('span', 'Collect')]),
                        h('span', { key: 'reply', style: { cursor: 'pointer' } }, [h('span', 'Reply')])
                      ],
                      avatar: () => [
                        h(
                          ArcoDesignVue.Avatar,
                          {},
                          {
                            default: () => [
                              h('img', {
                                alt: 'avatar',
                                src: 'https://p1-arco.byteimg.com/tos-cn-i-uwbnlip3yd/3ee5f13fb09879ecb5185e440cef6eb9.png~tplv-uwbnlip3yd-webp.webp'
                              })
                            ]
                          }
                        )
                      ]
                    }
                  ),
                  container: table.bodyDomContainer
                }
              });

              return {
                rootContainer: container,
                renderDefault: false
              };
            }
          }
        ],
        defaultHeaderRowHeight: 40,
        defaultRowHeight: 80,
        customConfig: {
          createReactContainer: true
        }
      }
    };
  }
});





 com = (
                  <dropdownCom
                    class={ns.b()}
                    ref={(e) => btn.registerRef('dropdown', e)}
                    items={btn.buttons.map((item) => {
                      return { button: item }
                    })}
                    v-slots={{
                      default: (item) => {
                        return (
                          <ElButton
                            onClick={() => runBtnFn(btn)}
                            style={{ height: '100%' }}
                          >
                            {btn.getLabel()}
                          </ElButton>
                        )
                      },
                      dropdown: (item) => {
                        let mc = (
                          <MenuCom
                            class={btnG.b()}
                            items={btn.buttons.map((item) => {
                              return { button: item } //
                            })}
                            v-slots={{
                              itemTitle: (item) => {
                                let _btn = item.config.button
                                return (
                                  <ElButton
                                    onClick={() => runBtnFn(_btn)}
                                    style={{ height: '100%' }}
                                  >
                                    {_btn.getLabel()}
                                  </ElButton>
                                )
                              },
                            }}
                          ></MenuCom>
                        )
                        return mc
                      },
                    }}
                  ></dropdownCom>
                )



                 // com = (
                //   <dropdownCom
                //     v-slots={{
                //       default: (config) => {
                //         const dropdown = config.dropdown
                //         let _com1 = (
                //           <div
                //             onClick={() => {
                //               dropdown.showDropdown()
                //             }}
                //             onMouseleave={() => {}}
                //             class="v-contextmenu"
                //             style={{ width: '100px', position: 'relative' }}
                //           >
                //             <ContextmenuItem>{btn.getLabel()}</ContextmenuItem>
                //           </div>
                //         )
                //         return _com1
                //       },

                //       dropdown: () => {
                //         let menu = <Contextmenu></Contextmenu>
                //         return menu
                //       },
                //     }} //
                //   ></dropdownCom>
                // )



                // if (this.permission.loadData == false) {
    //   //@ts-ignore
    //   if (this.permission.loadDataTime != null) {
    //     return
    //   }
    //   //@ts-ignore
    //   this.permission.loadDataTime = setTimeout(() => {
    //     this.permission.loadDataTime = null
    //     this.permission.loadData = true
    //     this.loadData()
    //   }, 1000);
    //   return //
    // }


    // nextTick(async () => {
    //   let now = Date.now().toString()
    //   console.time(now)
    //   if (globalValue.length > 0) {
    //     _data1 = _data1.filter((v) => {
    //       let _shtml = v['_shtml'] //
    //       let reg = new RegExp(globalValue, 'g') //
    //       if (reg.test(_shtml)) {
    //         return true
    //       }
    //       return false
    //     })
    //   }
    //   const sortconfig = _sortState //è‡ªå®šä¹‰çš„æ’åºé…ç½®
    //   //@ts-ignore
    //   const _sortConfig = sortconfig?.sort((s1, s2) => {
    //     //@ts-ignore
    //     return 0 //
    //   })
    //   let _data3 = _data1 //
    //   if (_filterConfig.length > 0) {
    //     for (const { field, indexArr } of _filterConfig) {
    //       if (indexArr?.length > 0) {
    //         const indexSet = new Set(indexArr)
    //         _data3 = _data3.filter((item) => indexSet.has(item[field]))
    //       }
    //     }
    //   }
    //   _data3 = _sortConfig//
    //     ?.reduce((res, item, i) => {
    //       const field = item.field
    //       const type = item.type
    //       let order = item.order
    //       // debugger//
    //       const colType: string = 'number' //ç±»å‹//
    //       const _data4 = combineAdjacentEqualElements(
    //         res, //
    //         field,
    //         i,
    //         // colType,
    //         // type,
    //         type,
    //         order,
    //       )
    //       return _data4
    //     }, _data1)
    //     .flat(sortconfig?.length)

    //   console.timeEnd(now) //
    //   this.updateCanvas({
    //     data: _data3, //
    //   })
    // })
    

     // _internalIconsStyle: {},
    // isPivot: false,
    // name: 'DEFAULT',
    // internalTheme: {
    //   obj: {
    //     name: 'DEFAULT',
    //     underlayBackgroundColor: '#FFF',
    //     defaultStyle: {
    //       borderColor: '#E1E4E8',
    //       color: '#000',
    //       bgColor: '#ECF1F5',
    //     },
    //     headerStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //       bgColor: '#ECF1F5',
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     rowHeaderStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //       bgColor: '#ECF1F5',
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     cornerHeaderStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //     },
    //     bodyStyle: {
    //       fontSize: 14,
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     frameStyle: {
    //       borderColor: '#E1E4E8',
    //       borderLineWidth: 1,
    //       borderLineDash: [],
    //       cornerRadius: 0,
    //       shadowBlur: 0,
    //       shadowOffsetX: 0,
    //       shadowOffsetY: 0,
    //       shadowColor: 'black',
    //     },
    //     columnResize: {
    //       lineWidth: 1,
    //       lineColor: '#416EFF',
    //       bgColor: '#D9E2FF',
    //       width: 3,
    //     },
    //     frozenColumnLine: {
    //       shadow: {
    //         width: 3,
    //         startColor: 'rgba(225, 228, 232, 0.6)',
    //         endColor: 'rgba(225, 228, 232, 0.6)',
    //       },
    //     },
    //     selectionStyle: {
    //       cellBgColor: 'rgba(0, 0, 255,0.1)',
    //       cellBorderLineWidth: 2,
    //       cellBorderColor: '#0000ff',
    //     },
    //     tooltipStyle: {
    //       bgColor: '#FFF',
    //       color: '#000',
    //       fontSize: 12,
    //       fontFamily: 'Arial,sans-serif',
    //     },
    //   },
    //   superTheme: {
    //     name: 'DEFAULT',
    //     underlayBackgroundColor: '#FFF',
    //     defaultStyle: {
    //       borderColor: '#E1E4E8',
    //       color: '#000',
    //       bgColor: '#ECF1F5',
    //     },
    //     headerStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //       bgColor: '#ECF1F5',
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     rowHeaderStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //       bgColor: '#ECF1F5',
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     cornerHeaderStyle: {
    //       fontSize: 16,
    //       fontWeight: 'bold',
    //     },
    //     bodyStyle: {
    //       fontSize: 14,
    //       hover: {
    //         cellBgColor: '#CCE0FF',
    //         inlineRowBgColor: '#F3F8FF',
    //         inlineColumnBgColor: '#F3F8FF',
    //       },
    //     },
    //     frameStyle: {
    //       borderColor: '#E1E4E8',
    //       borderLineWidth: 1,
    //       borderLineDash: [],
    //       cornerRadius: 0,
    //       shadowBlur: 0,
    //       shadowOffsetX: 0,
    //       shadowOffsetY: 0,
    //       shadowColor: 'black',
    //     },
    //     columnResize: {
    //       lineWidth: 1,
    //       lineColor: '#416EFF',
    //       bgColor: '#D9E2FF',
    //       width: 3,
    //     },
    //     frozenColumnLine: {
    //       shadow: {
    //         width: 3,
    //         startColor: 'rgba(225, 228, 232, 0.6)',
    //         endColor: 'rgba(225, 228, 232, 0.6)',
    //       },
    //     },
    //     selectionStyle: {
    //       cellBgColor: 'rgba(0, 0, 255,0.1)',
    //       cellBorderLineWidth: 2,
    //       cellBorderColor: '#0000ff',
    //     },
    //     tooltipStyle: {
    //       bgColor: '#FFF',
    //       color: '#000',
    //       fontSize: 12,
    //       fontFamily: 'Arial,sans-serif',
    //     },
    //   },
    // },
    nextTick(async () => {
      // let system = this.getSystem()
      // let tableConfig = await system.getDefaultPageLayout(this.tableName) //
      // console.log(tableConfig, 'tableConfig') //
    })


     com = (
        <formCom
          itemSpan={24}
          items={[
            {
              field: 'email',
              label: 'é‚®ç®±',
              required: true,
            },
            {
              field: 'password',
              label: 'å¯†ç ',
              required: true,
              password: true,
            },
          ]} //
        ></formCom> //
      )


       let btns = [
      {
        label: 'æŒ‰é’®1',
      },

      {
        label: 'æŒ‰é’®5',
        children: [
          {
            label: 'æŒ‰é’®5-111',
          },
        ],
        items: [
          {
            label: 'æŒ‰é’®5-222',
          },
          {
            label: 'æŒ‰é’®5-333',
            items: [
              {
                label: 'æŒ‰é’®5-444',
                disabled: true,
              }, //
            ],
          },
        ],
      },
    ]


    {/* {isFoldFields.value && (
                  <ElHeader class="operation" style="display: flex;flex-derection: row;justify-content: space-between;">
                    <div>
                      <Icon class="icon" icon="save" onClick={() => handleOperation(4)} />
                      {props.isShowClear && <Icon class="icon" icon="clear0" onClick={() => handleOperation(2)} />}
                      {slots['operation-left'] && slots['operation-left']()}
                    </div>
                    <div>
                      <DeviceSwitch modelValue={state.platform} onUpdate:modelValue={switchPlatform} />
                      <ElButton
                        onClick={() => {
                          formIns.runTestMethod() //
                        }}
                      >
                        æµ‹è¯•
                      </ElButton>
                    </div>
                    <div>
                      {slots['operation-right'] && slots['operation-right']()}
                      {props.isShowI18n && (
                        <ElDropdown onCommand={(command) => fireEvent('lang', command)}>
                          <Icon class="icon" icon="language" />
                          {{
                            dropdown: () => (
                              //
                              <ElDropdownMenu>
                                <ElDropdownItem command="zh-cn" disabled={lang.value === 'zh-cn'}>
                                  ä¸­æ–‡
                                </ElDropdownItem>
                                <ElDropdownItem command="en" disabled={lang.value === 'en'}>
                                  English
                                </ElDropdownItem>
                              </ElDropdownMenu>
                            ),
                          }}
                        </ElDropdown>
                      )}
                      <Icon class="icon" icon="preview" onClick={() => handleOperation(3)} />
                    </div>
                  </ElHeader>
                )} */}




                let items = this.items
    let rows = []
    let _pcLayout = this._pcLayout
    if (_pcLayout != null) {
      return _pcLayout //
    }
    let _index = 0
    for (const item of items) {
      let index = item.getRowIndex()
      let _row = rows[index]
      if (_row == null) {
        let nRow = this.createTrRow()
        rows[index] = nRow
        let initCols = Array(24)
          .fill(null)
          .map((row, i) => {
            let id = this.uuid()
            return {
              type: 'td',
              style: {},
              options: {
                colspan: 1,
                rowspan: 1,
                isMerged: false,
              },
              id: id,
              key: `td_${id}`,
              list: [],
            }
          })
        nRow.columns.push(...initCols)
        _row = nRow
        _index = 0
      }
      let _cols = item.getTdColumn()
      let span = item.getSpan()
      // _row.columns.push(...item.getTdColumn())
      _row.columns.splice(_index, span, ..._cols)
      _index += span //
    }
    let pcLayout = this.pcLayout
    pcLayout.columns[0].rows = rows
    if (pcLayout.columns[0].rows.length == 0) {
      let nRow = this.createTrRow()
      let td = Array(1)
        .fill(null)
        .map((row, i) => {
          let id = this.uuid()
          return {
            type: 'td',
            style: {},
            options: {
              colspan: 1,
              rowspan: 1,
              isMerged: false,
            },
            id: id,
            key: `td_${id}`,
            list: [],
          }
        })
      nRow.columns.push(...td)
      pcLayout.columns[0].rows.push(nRow) //
    }
    return pcLayout

     let offset = Math.ceil(
                (oldWidth +
                  Math.round((e.clientX - oldX) / columnWidth) * columnWidth) /
                  columnWidth,
              )
              if (offset >= 24) {
                offset = 24
              }
              if (offset <= 6) {
                offset = 6
              }
              let isCol = props.data.type == 'col'
              if (isCol) {
                let allCols = props.data?.context?.parent?.columns || []
                let allSpan = allCols
                  .filter((col) => col.id !== props.data.id)
                  .map((col) => col.options.span)
                  .reduce((pre, cur) => pre + cur)
                let _allSpan = allSpan + offset
                if (_allSpan > 24) {
                  return //
                }
                props.data.options.span = offset
              }


              // _props.headerCustomLayout = (args) => {
    //   const { table, row, col, rect } = args
    //   const { height, width } = rect ?? table.getCellRect(col, row)
    //   // console.log(width,'testWidth')//
    //   const container = createGroup({
    //     height,
    //     width,
    //     display: 'flex',
    //     flexDirection: 'column',
    //     alignItems: 'center',
    //     justifyContent: 'center',
    //   })
    //   const checkboxGroup = createGroup({
    //     display: 'flex',
    //     flexDirection: 'column',
    //     boundsPadding: [0, 0, 0, 0],
    //     justifyContent: 'center', //
    //   })
    //   container.appendChild(checkboxGroup)
    //   const checkbox1 = new CheckBox({
    //     text: {
    //       text: '', //
    //     },
    //     disabled: false, //
    //     checked: _this.table.isCheckAll, //
    //     boundsPadding: [0, 0, 0, 0],
    //   }) //
    //   checkbox1.render()
    //   checkboxGroup.appendChild(checkbox1)
    //   checkbox1.addEventListener('checkbox_state_change', (e) => {
    //     const target = e.target ////
    //     let attributes = target.attribute //
    //     let checked = attributes.checked
    //     _this.table.updateCheckboxAll(checked)
    //   }) //
    //   return {
    //     rootContainer: container,
    //     renderDefault: false,
    //   }
    // } //



    let allFields = row.fields
    let allDetailTable = allFields
      .map((row) => {
        let tableType = row['tableType']
        if (tableType == 'detail') {
          return row
        }
      })
      .filter((row) => row != null) //è·å–æ‰€æœ‰çš„å­è¡¨
    let tabLayout = {
      // ...this.createNodeIdKey('tab'),
      ...this.createNodeIdKey('inline'),
      columns: [
        {
          ...this.createNodeIdKey('grid'),
          options: {
            span: 24,
            offset: 0,
            push: 0,
            pull: 0,
            style: {},
          },
          columns: [
            {
              ...this.createNodeIdKey('col'),
              list: [
                {
                  ...this.createNodeIdKey('inline'),
                  columns: [
                    {
                      ...this.createNodeIdKey('tabs'),
                      columns: [
                        allDetailTable.map((row) => {
                          let _t = this.createColLayout(row.id)
                          return _t //
                        }),
                      ],
                    },
                  ],
                },
              ],
            },
          ],
        },
      ],
    }
    let fL = []
    let _formLayout = {
      ...this.createNodeIdKey('inline'),
      columns: [
        {
          ...this.createNodeIdKey('grid'),
          options: {
            span: 24,
            offset: 0,
            push: 0,
            pull: 0,
            style: {},
          },
          columns: [
            {
              ...this.createNodeIdKey('col'),
              list: [
                {
                  ...this.createNodeIdKey('inline'),
                  columns: [
                    {
                      ...this.createNodeIdKey('tabs'),
                      columns: fL,
                    },
                  ],
                },
              ],
            },
          ],
        },
      ],
    }
    let pcLayout = [_formLayout]
    if (allDetailTable.length > 0) {
      pcLayout.push(tabLayout) //
    }
    return pcLayout
    // let _props = getDefaultPageProps()
    // let obj = {} //
    // Object.entries(_props).forEach(([key, value]) => {
    //   //@ts-ignore
    //   let _default = value.default
    //   if (typeof _default == 'function' && value.type != Function) {
    //     //@ts-ignore
    //     _default = _default() //
    //   }
    //   obj[key] = _default //
    // })
    // obj = {
    //   ...obj,
    //   ...layoutConfig,
    // } //
    // //@ts-ignore
    // obj.tableName = tableName
    // let pageDesign = new PageDesign(obj)
    // pageDesign.tableName = tableName //
    // pageDesign.setLayoutData(layoutConfig)
    // //è¿™æ˜¯ç¼–è¾‘çš„é¡µé¢//
    // return pageDesign


     // {
        //   type: 'dform',
        //   label: 'è¡¨å•',
        //   icon: 'input',
        //   id: 'KRg51faFSk3H2piRFbrQg',
        //   options: {
        //     clearable: true,
        //     isShowWordLimit: false,
        //     renderType: 1,
        //     disabled: false,
        //     showPassword: false,
        //     defaultValue: '',
        //     placeholder: '',
        //     labelWidth: 100,
        //     isShowLabel: true,
        //     required: false,
        //     min: null,
        //     max: null,
        //   },
        //   style: {
        //     width: {
        //       pc: '100%',
        //       mobile: '100%',
        //     },
        //   },
        //   key: 'dform_KRg51faFSk3H2piRFbrQg',
        // },



          let arr = [
            {
              // text: 'åˆå¹¶å•å…ƒæ ¼',
              range: {
                start: {
                  col: 3,
                  row: 8,
                },
                end: {
                  col: 7,
                  row: 10,
                },
              },
              style: {
                bgColor: '#ccc',
              },
              customLayout: (args) => {
                const { table, row, col, rect, value } = args
                const { height, width } = rect ?? table.getCellRect(col, row)
                let c = createGroup({
                  height,
                  width,
                  display: 'flex',
                  alignItems: 'center',
                })
                let t = createText({
                  text: 'æµ‹è¯•',
                  fontSize: 16,
                  fill: 'black',
                  fontWeight: 'bold',
                  boundsPadding: [0, 0, 0, 0],
                  lineDashOffset: 0,
                })
                c.add(t) //
                return {
                  rootContainer: c, //
                }
              },
            },
          ]
          let ins = tableIns.getInstance()
          ins.options.customMergeCell = arr //


           {isFoldFields.value && (
                  <ElHeader class="operation" style="display: flex;flex-derection: row;justify-content: space-between;">
                    <div>
                      <Icon class="icon" icon="save" onClick={() => handleOperation(4)} />
                      {props.isShowClear && <Icon class="icon" icon="clear0" onClick={() => handleOperation(2)} />}
                      {slots['operation-left'] && slots['operation-left']()}
                    </div>
                    <div>
                      <DeviceSwitch modelValue={state.platform} onUpdate:modelValue={switchPlatform} />
                      <ElButton
                        onClick={() => {
                          formIns.runTestMethod() //
                        }}
                      >
                        æµ‹è¯•
                      </ElButton>
                    </div>
                    <div>
                      {slots['operation-right'] && slots['operation-right']()}
                      {props.isShowI18n && (
                        <ElDropdown onCommand={(command) => fireEvent('lang', command)}>
                          <Icon class="icon" icon="language" />
                          {{
                            dropdown: () => (
                              //
                              <ElDropdownMenu>
                                <ElDropdownItem command="zh-cn" disabled={lang.value === 'zh-cn'}>
                                  ä¸­æ–‡
                                </ElDropdownItem>
                                <ElDropdownItem command="en" disabled={lang.value === 'en'}>
                                  English
                                </ElDropdownItem>
                              </ElDropdownMenu>
                            ),
                          }}
                        </ElDropdown>
                      )}
                      <Icon class="icon" icon="preview" onClick={() => handleOperation(3)} />
                    </div>
                  </ElHeader>
                )}


                 // if (gColumns != null) {
        //   list = gColumns
        //   let _el = {
        //     type: 'inline',
        //     columns: [newElement],
        //   }
        //   newElement = _el //
        //   _oldEl1.list.push(newElement) //
        //   newElement = _oldEl1
        //   newElement = ER.wrapElement(newElement, false, true, true) //
        //   inserColIndex = _nIndex //
        //   _parent2 = gColumns //
        // }



         // nSpan = _span - Number(_span1)
                // //ä½¿ç”¨colè¿›è¡ŒåŒ…è£¹
                // _nIndex = newIndex
                // _oldEl1 = {
                //   type: 'col',
                //   list: [],
                //   options: {
                //     span: _span1,
                //   },
                // }


                 // (col, row, table) => {
      //   let obj= {
      //     range: {
      //       start: {
      //         col: 3,
      //         row: 8,
      //       },
      //       end: {
      //         col: 7,
      //         row: 10,
      //       },
      //     },
      //     style: {
      //       bgColor: '#ccc',
      //     },
      //   } //
      //   return obj
      // },
      // multipleSort: true,


      _props.headerCustomLayout = (args) => {
      const { table, row, col, rect } = args
      const { height, width } = rect ?? table.getCellRect(col, row)
      // console.log(width,'testWidth')//
      const container = createGroup({
        height: height - 2,
        width: width - 2,
        x: 1,
        y: 1, //
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
      })
      const checkboxGroup = createGroup({
        display: 'flex',
        flexDirection: 'column',
        boundsPadding: [0, 0, 0, 0],
        justifyContent: 'center', //
      })
      container.appendChild(checkboxGroup)
      const checkbox1 = new CheckBox({
        text: {
          text: '', //
        },
        disabled: false, //
        checked: _this.table.isCheckAll, //
        boundsPadding: [0, 0, 0, 0],
      }) //
      checkbox1.render()
      checkboxGroup.appendChild(checkbox1)
      checkbox1.addEventListener('checkbox_state_change', (e) => {
        const target = e.target ////
        let attributes = target.attribute //
        let checked = attributes.checked
        _this.table.updateCheckboxAll(checked)
      }) //
      return {
        rootContainer: container,
        renderDefault: false,
      }
    }

     // borderColor: (config) => {
        //   let _table = config.table
        //   let record = _table.getRecordByCell(config.col, config.row)
        //   let color = 'RGB(225, 228, 232)' //
        //   let _index = record._index
        //   let validateMap = table.validateMap
        //   let errStr = validateMap[_index]
        //   //æŠ¥é”™äº†//
        //   if (errStr) {
        //     let allField = errStr.map((row) => row.field)
        //     if (allField.includes(this.getField())) {
        //       color = 'red'
        //     } //
        //   }
        //   return color
        // },
        // borderLineWidth: (config) => {
        //   let _table = config.table
        //   let record = _table.getRecordByCell(config.col, config.row)
        //   let color = 1 //
        //   let _index = record._index
        //   let validateMap = table.validateMap
        //   let errStr = validateMap[_index]
        //   //æŠ¥é”™äº†//
        //   if (errStr) {
        //     let allField = errStr.map((row) => row.field)
        //     if (allField.includes(this.getField())) {
        //       color = 3
        //     } //
        //   }
        //   return color
        // }, //
        // bgColor: (config) => {
        //   //
        //   let _table = config.table
        //   let record = _table.getRecordByCell(config.col, config.row)
        //   let gValue = table.globalConfig.value
        //   let value = config.value
        //   let color = null
        //   if (record == table.tableData.curRow) {
        //     color = 'RGB(200, 190, 230)'
        //   }
        //   if (gValue.length > 0) {
        //     let reg = new RegExp(gValue, 'g')
        //     if (reg.test(value)) {
        //       color = 'RGB(230, 220, 230)' //
        //     }
        //   }
        //   return color
        // }, //


        // let length = this.table.templateProps.data.length
      // let _length = length / 5



      // let dialogCom = (
      //   <ElDialog destroyOnClose fullscreen class="previewDialog" v-model={state.previewVisible} onClosed={() => (previewPlatform.value = 'pc')}>
      //     {{
      //       header: () => <DeviceSwitch modelValue={previewPlatform.value} onUpdate:modelValue={(val) => handleOperation(7, val)} />,
      //       default: () => (
      //         <ElScrollbar>
      //           <div class={{ previewDialogWrap: true, mobilePreview: previewPlatform.value === 'mobile' }}>
      //             <ErFormPreview {...props} formIns={formIns} ref={setPreviewRef} />
      //           </div>
      //         </ElScrollbar>
      //       ),
      //     }}
      //   </ElDialog>
      // )


      // let _arr = new Array(row).fill(null)
      // let _arr1 = []
      // for (let r of _arr) {
      //   let _r = await this.createDefaultRow(tableName) //
      // }

       // bgColor: (config) => {
        //   let row = config.row
        //   let _col = this.getIndexColor(row)
        //   return _col
        // }, //


         container.on('dblclick', (config) => {
        // console.log('æˆ‘æ‰§è¡Œäº†') //
        // if (this.isHeaderdown != false) {
        //   //æ‰§è¡Œ
        //   let title = this.getTitle()
        //   if (this.table.templateEditCell != null) {
        //     this.table.clearEditCell() //
        //     setTimeout(() => {
        //       this.table.startEditCell(col, row, title) //
        //     }, 100)
        //   } else {
        //     this.table.startEditCell(col, row, title) //
        //   }
        // }
        // this.isHeaderdown = true
        // setTimeout(() => {
        //   this.isHeaderdown = false ////
        // }, 300)
        // let title = this.getTitle()
        // if (this.table.templateEditCell != null) {
        //   this.table.clearEditCell() //
        //   setTimeout(() => {
        //     this.table.startEditCell(col, row, title) //
        //   }, 100)
        // } else {
        //   this.table.startEditCell(col, row, title) //
        // }
      })


        // let instance = this.getInstance()
    // let _index1 = instance.records.findIndex(
    //   (r) => r['_index'] == row['_index'],
    // )
    // let _index2 = instance.records.findIndex(
    //   (r) => r['_index'] == oldCurRow['_index'],
    // )
    // let id = this.uuid()
    // console.time(id)
    // let bodyIndex = instance.getTableIndexByRecordIndex(_index1)
    // let bodyIndex1 = instance.getTableIndexByRecordIndex(_index2)
    // // console.log(bodyIndex, bodyIndex1) //
    // // let _cell=instance.getCellInfo(null,bodyIndex)
    // // let cells = instance.getAllCells(null, bodyIndex)
    // // let cell1 = instance.getAllCells(null, bodyIndex1)
    // // console.log(cells) //
    // console.timeEnd(id) //


      // return () => {
    //   let leftMenu = (
    //     <menuCom
    //       items={systemIns.getMenuItems()}
    //       ref={registerMenu}
    //       showSearch={true}
    //       searchFn={(config) => {
    //         let value = config.value
    //         let item = config.item
    //         let _config = item.config.navname //
    //         let reg = new RegExp(value, 'gi') //
    //         let bool = false
    //         let tableName = item.config.tableName
    //         if (reg.test(_config)) {
    //           bool = true
    //         }
    //         if (reg.test(tableName)) {
    //           bool = true
    //         }
    //         return bool //
    //       }}
    //       v-slots={{
    //         subItemTitle: (item) => {
    //           let config = item.config
    //           let navname = config.navname
    //           return <div>{navname}</div>
    //         },
    //         itemTitle: (item) => {
    //           let config = item.config
    //           let navname = config.navname
    //           let com = <div>{navname}</div> //
    //           return com
    //         },
    //       }}
    //     ></menuCom>
    //   )
    //   let tableTab = (
    //     <tabCom
    //       height={30}
    //       items={systemIns.getTabItems()}
    //       v-slots={{
    //         item: (item) => {
    //           return (
    //             <div class="home-tab-item">
    //               <div class="home-tab-item-label">{item.getLabel()}</div>
    //             </div>
    //           )
    //         },
    //       }}
    //     ></tabCom>
    //   )
    //   const allShowEntity = systemIns.getShowEntityArr() //
    //   let _showCom = allShowEntity.map((item: any) => {
    //     //
    //     let _com = (
    //       <PageCom isDesign={false} key={item.id} formIns={item}></PageCom>
    //     )
    //     return _com
    //   })
    //   return (
    //     <div
    //       class={ns.b()}
    //       style={{ display: 'flex', width: '100vw', height: '100vh' }}
    //     >
    //       <div style={{ width: '300px', height: '100%' }}>{leftMenu}</div>
    //       <div class="flex flex-col flex-1 h-full bg-red">
    //         <div class="w-full bg-white tab-line">{tableTab}</div>
    //         <div class="" style={{ height: '30px' }}>
    //           <er-button-group
    //             items={[
    //               {
    //                 label: 'test',
    //                 fn: async () => {
    //                   // let _b = await systemIns.createPageDesign('t_SdOrder') //
    //                   // console.log(_b, 'testB') //
    //                   systemIns.routeOpen('t_SdOrder') //
    //                 },
    //               },
    //             ]}
    //           ></er-button-group>
    //         </div>
    //         <div class="flex-1">{_showCom}</div>
    //       </div>
    //     </div>
    //   )
    // }

     app.hooks({
    around: [
      async (context, next) => {
        console.log('è¿™ä¸ªæ˜¯ç¯ç»•é’©å­') //
        await next()
      }, //
    ],
  })

   return () => (
      <div
        style={{
          height: '100vh',
          width: '100vw',
        }}
      >
        <div class="w-full h-full bg-black"></div>
      </div>
    )


     // let _res = await systemIns.createPageEditDesign('t_SdOrder') //
                        // systemIns.openDialog({
                        //   title: 'ç¼–è¾‘é¡µé¢',
                        //   width: '1000px',
                        //   height: '500px', //b
                        //   createFn: () => {
                        //     return {
                        //       component: pageCom,
                        //       props: {
                        //         formIns: _res,
                        //       }, //
                        //     }//
                        //   },
                        // })

                        {/* <div class="flex items-center justify-center flex-grow">
                <img
                  src="illustration.png"
                  alt="Illustration"
                  class="object-contain w-full"
                />
              </div>
              <div class="flex mt-6 space-x-6">
                <div class="flex items-center space-x-2">
                  <img src="windows-icon.png" alt="Windows" class="w-5 h-5" />
                  <span class="text-sm">Windows</span>
                </div>
                <div class="flex items-center space-x-2">
                  <img src="mac-icon.png" alt="Mac" class="w-5 h-5" />
                  <span class="text-sm">Mac</span>
                </div>
              </div> */}


               let btnGText = (
        <div class="" style={{ height: '30px' }}>
          <er-button-group
            items={[
              {
                label: 'å½“å‰çœŸå®è¡¨è®¾è®¡',
                fn: async () => {
                  let currentPage = systemIns.getCurrentPageDesign()
                  let rTName = currentPage.getRealTableName()
                  await system.designTableColumns(rTName) //
                },
              },
              //
              {
                label: 'è¿›å…¥è®¾è®¡', //
                fn: async () => {
                  let currentPage = systemIns.getCurrentPageDesign()
                  currentPage.setCurrentDesign(true) //
                },
              },
              {
                label: 'ç¦»å¼€è®¾è®¡',
                fn: async () => {
                  let cp = systemIns.getCurrentPageDesign()
                  cp.setCurrentDesign(false) //
                },
              },
              {
                label: 'ä¿å­˜è®¾è®¡',
                fn: async () => {
                  let currentPage = systemIns.getCurrentPageDesign()
                  currentPage.saveTableDesign()
                },
              },
              {
                label: 'è¿›å…¥ç¼–è¾‘é¡µé¢',
                fn: async () => {
                  systemIns.routeOpen('t_SdOrder---edit') //
                },
              },
              {
                label: 'æ‰“å°layout', //
                fn: async () => {
                  let currentPage = systemIns.getCurrentPageDesign()
                  let layout = currentPage.getLayoutData()
                  console.log(layout) //
                  console.log(currentPage, 'testPage') //
                },
              },
              {
                label: 'å½“å‰é¡µé¢è®¾è®¡',
                fn: async () => {
                  await systemIns.designCurrentPageConfig() //
                },
              },
            ]}
          ></er-button-group>
        </div>
      )

      {
        dragHeaderMode: 'column',
        validateDragOrderOnEnd: (start, end) => {
          let col1 = start.col
          let row1 = start.row
          let col2 = end.col
          let row2 = end.row
          let f = this.getInstance().getHeaderField(col1, row1)
          let f1 = this.getInstance().getHeaderField(col2, row2)
          let f1C = this.getColumns().find((c) => c.getField() == f)
          let f2C = this.getColumns().find((c) => c.getField() == f1)
          if (f1C == f2C) {
            return false //
          }
          let isFrozen = f2C.getIsFrozen()
          let isFrozen1 = f1C.getIsFrozen()
          if (isFrozen || isFrozen1) {
            //
            return false
          }
          nextTick(() => {
            let fs = this.getInstance().columns.map((col, i) => {
              let obj = {
                field: col.field,
                order: i + 1,
              }
              return obj
            })
            this.changeSortOrder(fs as any) //
          })
          return true
        },
      }


      // let icon = createText({
        //   text: t,
        //   fontSize: 15,
        //   cursor: 'pointer', //
        //   x: 0,
        //   y: 0, //
        //   overflow: 'hidden',
        //   fill: 'black',
        //   boundsPadding: [0, 0, 0, 3 + _level * 15], //
        //   lineDashOffset: 0,
        // })
        // let _g2=createGroup({

        // })

        _g1.on('click', () => {
          // this.table.openTreeRow(col, row) //
          // // nextTick(() => {
          // //   _this.table.updateIndexArr.add(_index)
          // // })
          // console.log(args, 'sfjsdklfsdlfsd') //
        })


         // filterChildren(children: any[], row: any) {
  //   let globalValue = this.globalConfig.value
  //   let _children = children
  //   if (globalValue.length > 0) {
  //     _children = _children.filter((v) => {
  //       let _shtml = v['_shtml'] //
  //       let reg = new RegExp(globalValue, 'gi') ////
  //       if (reg.test(_shtml)) {
  //         this.globalRowSet.add(v['_index'])
  //         return true
  //       }
  //       this.globalRowSet.delete(v['_index']) ////
  //       return false
  //     })
  //   }
  //   let _data1 = _children
  //   let sortState = this.sortCache
  //   let _sortState = toRaw(sortState)
  //   let sortconfig = _sortState //è‡ªå®šä¹‰çš„æ’åºé…ç½®
  //   //@ts-ignore
  //   let _data3 = _sortConfig
  //     ?.reduce((res, item, i) => {
  //       const field = item.field
  //       const type = item.type
  //       let order = item.order
  //       const colType: string = 'number' //ç±»å‹//
  //       const _data4 = combineAdjacentEqualElements(
  //         res, //
  //         field,
  //         i, //
  //         // colType,
  //         // type,
  //         type,
  //         order,
  //       )
  //       return _data4
  //     }, _data1)
  //     .flat(sortconfig?.length) //
  // }

   // systemIns.designSystemNavs().then((res) => {
    //   _config = res
    //   show.value = true
    // })


      /* 
        {
                flex: 1,
                width: '100%',
                overflow: 'hidden', //
                borderLeft: '1px solid RGB(225, 228, 232)',
                borderRight: '1px solid RGB(225, 228, 232)',
                borderTop: '1px solid RGB(225, 228, 232)',
                boxSizing: 'border-box',
              }
      
      */

      // async getDefaultPageLayout(name?: string) {
  //   let http = this.getHttp()
  //   let _data = await http.post(
  //     'entity',
  //     'getDefaultPageLayout',
  //     {
  //       tableName: name,
  //     }, //
  //   ) //
  //   return _data //
  // }
   // getFieldsDesignConfig() {
  //   // let _fieldConfig = JSON.parse(JSON.stringify(fieldsConfig))
  //   // return _fieldConfig
  // }

  // let showSearchIcon = computed(() => {
    //   let s = formitem.getIsShowSearchIcon()
    //   return s
    // })


    // let _pcLayout = this._pcLayout
    // if (_pcLayout != null) {
    //   return _pcLayout //
    // }


     // let fConfig = {
        //   itemSpan: 12,
        //   items: [
        //     {
        //       label: 'æ ‡é¢˜', //
        //       field: 'title',
        //       editType: 'string', //
        //     },
        //     {
        //       label: 'å€¼æ›´æ–°äº‹ä»¶',
        //       filed: 'itemChange',
        //       editType: 'code', //
        //     },
        //     {
        //       label: 'é»˜è®¤å€¼',
        //       field: 'defaultValue',
        //       type: 'code', //
        //     },
        //     {
        //       label: 'é»˜è®¤å€¼ç±»å‹',
        //       field: 'defaultValueType',
        //       type: 'select',
        //       options: {
        //         options: [
        //           {
        //             label: 'å‡½æ•°ç±»å‹',
        //             value: 'function',
        //           },
        //           {
        //             label: 'æ™®é€šç±»å‹',
        //             value: 'normal',
        //           },
        //         ],
        //       },
        //     },
        //     {
        //       label: 'ç¼–è¾‘ç±»å‹',
        //       field: 'editType',
        //       type: 'select',
        //       options: {
        //         options: [
        //           {
        //             label: 'è¾“å…¥æ¡†',
        //             value: 'string',
        //           },
        //         ],
        //       },
        //     },
        //   ],
        //   data: _config, //
        //   height: 500,
        //   width: 900,
        // }

        // _col1 = _col1.sort((a, b) => {
    //   let isFrozen = b.isFrozen
    //   if (isFrozen === true) {
    //     return -1
    //   }
    //   return 0
    // })
    // _col1 = _col1.sort((a, b) => {
    //   let isLeftFrozen = a.isLeftFrozen
    //   if (isLeftFrozen === true) {
    //     return -1
    //   }
    //   return 0
    // })
    // _col1=_col1.sort((a,b)=>{
    // })


    
// export const fieldsConfig = [
//   {
//     name: 'é¢„è®¾å­—æ®µ',
//     id: 'defaultField',
//     children: [
//       {
//         type: 'input',
//         label: 'é‚®ç®±',
//         icon: 'email',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           renderType: 2,
//           disabled: false,
//           showPassword: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//         },
//       },
//       {
//         type: 'input',
//         label: 'æ‰‹æœºå·',
//         icon: 'cellphone',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           renderType: 4,
//           disabled: false,
//           showPassword: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//         },
//       },
//       {
//         type: 'input',
//         label: 'ç½‘å€',
//         icon: 'url',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           renderType: 5,
//           disabled: false,
//           showPassword: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//         },
//       },
//       {
//         type: 'region',
//         label: 'çœå¸‚åŒº',
//         icon: 'location',
//         key: '',
//         id: '',
//         options: {
//           placeholder: '',
//           required: false,
//           isShowLabel: true,
//           labelWidth: 100,
//           defaultValue: '',
//           selectType: 3,
//           filterable: true,
//         },
//       },
//       {
//         type: 'input',
//         label: 'èº«ä»½è¯å·',
//         icon: 'ID',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           renderType: 3,
//           disabled: false,
//           showPassword: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//         },
//       },
//     ],
//   },
//   {
//     name: 'åŸºç¡€å­—æ®µ',
//     id: 'field',
//     children: [
//       {
//         type: 'input',
//         label: 'å•è¡Œæ–‡æœ¬',
//         icon: 'input',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           isShowWordLimit: false,
//           renderType: 1,
//           disabled: false,
//           showPassword: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           min: null,
//           max: null,
//         },
//       },
//       // {
//       //   type: 'textarea',
//       //   label: 'å¤šè¡Œæ–‡æœ¬',
//       //   icon: 'textarea',
//       //   key: '',
//       //   id: '',
//       //   options: {
//       //     clearable: true,
//       //     isShowWordLimit: false,
//       //     rows: 6,
//       //     defaultValue: '',
//       //     placeholder: '',
//       //     disabled: false,
//       //     labelWidth: 100,
//       //     isShowLabel: true,
//       //     required: false,
//       //     min: null,
//       //     max: null
//       //   }
//       // },
//       {
//         type: 'number',
//         label: 'æ•°å­—',
//         icon: 'numbers',
//         key: '',
//         id: '',
//         options: {
//           min: 0,
//           max: null,
//           step: 1,
//           precision: 0,
//           disabled: false,
//           controls: true,
//           controlsPosition: true,
//           defaultValue: null,
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           minlength: null,
//           maxlength: null,
//         },
//       },
//       {
//         type: 'radio',
//         label: 'å•é€‰æ¡†',
//         icon: 'radio',
//         key: '',
//         id: '',
//         options: {
//           dataKey: '',
//           displayStyle: 'block',
//           defaultValue: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           disabled: false,
//           required: false,
//         },
//       },
//       {
//         type: 'checkbox',
//         label: 'å¤é€‰æ¡†',
//         icon: 'checkbox',
//         key: '',
//         id: '',
//         options: {
//           dataKey: '',
//           displayStyle: 'block',
//           defaultValue: [],
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           disabled: false,
//         },
//       },
//       {
//         type: 'select',
//         label: 'ä¸‹æ‹‰æ¡†',
//         icon: 'dropdown0',
//         key: '',
//         id: '',
//         options: {
//           dataKey: '',
//           filterable: true,
//           multiple: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           disabled: false,
//           clearable: true,
//           required: false,
//         },
//       },
//       {
//         type: 'time',
//         label: 'æ—¶é—´',
//         icon: 'time',
//         key: '',
//         id: '',
//         options: {
//           clearable: true,
//           format: 'HH:mm:ss',
//           valueFormat: 'HH:mm:ss',
//           defaultValue: null,
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           disabled: false,
//         },
//       },
//       {
//         type: 'date',
//         label: 'æ—¥æœŸ',
//         icon: 'calendar',
//         key: '',
//         id: '',
//         options: {
//           isShowWordLimit: false,
//           clearable: true,
//           format: 'YYYY-MM-DD',
//           defaultValue: null,
//           startTime: null,
//           endTime: null,
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           type: 'date',
//           required: false,
//           disabled: false,
//         },
//       },
//       {
//         type: 'rate',
//         label: 'è¯„åˆ†',
//         icon: 'rating',
//         key: '',
//         id: '',
//         options: {
//           max: 5,
//           allowHalf: false,
//           defaultValue: 0,
//           labelWidth: 100,
//           isShowLabel: true,
//           disabled: false,
//         },
//       },
//       // {
//       //   type: 'color',
//       //   label: 'é¢œè‰²',
//       //   icon: 'color-filling',
//       //   key: '',
//       //   id: '',
//       //   options: {
//       //     showAlpha: false,
//       //     defaultValue: '',
//       //     placeholder: '',
//       //     labelWidth: 100,
//       //     isShowLabel: true,
//       //     required: false,
//       //     requiredHint: '',
//       //     validation: '',
//       //     validationHint: '',
//       //     minlength: null,
//       //     maxlength: null
//       //   }
//       // },
//       {
//         type: 'switch',
//         label: 'å¼€å…³',
//         icon: 'switch',
//         key: '',
//         id: '',
//         options: {
//           defaultValue: true,
//           labelWidth: 100,
//           isShowLabel: true,
//           disabled: false,
//         },
//       },
//       {
//         type: 'slider',
//         label: 'æ»‘å—',
//         icon: 'slider',
//         key: '',
//         id: '',
//         options: {
//           min: 0,
//           max: 100,
//           step: 1,
//           defaultValue: 0,
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           disabled: false,
//         },
//       },
//       {
//         type: 'html',
//         label: 'å¯Œæ–‡æœ¬ç¼–è¾‘å™¨',
//         icon: 'html',
//         key: '',
//         id: '',
//         options: {
//           defaultValue: '',
//           placeholder: '',
//           action: '',
//           size: 1,
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           disabled: false,
//         },
//       },
//       {
//         type: 'cascader',
//         label: 'çº§è”æ¡†',
//         icon: 'cascader',
//         key: '',
//         id: '',
//         options: {
//           filterable: true,
//           multiple: false,
//           checkStrictly: false,
//           defaultValue: '',
//           placeholder: '',
//           labelWidth: 100,
//           isShowLabel: true,
//           required: false,
//           disabled: false,
//           clearable: true,
//         },
//       },
//       {
//         type: 'uploadfile',
//         label: 'ä¸Šä¼ æ–‡ä»¶',
//         icon: 'upload',
//         key: '',
//         id: '',
//         options: {
//           isShowLabel: true,
//           labelWidth: 100,
//           defaultValue: [],
//           multiple: false,
//           action: '',
//           limit: 1,
//           size: 5,
//           accept: '.png,.jpg',
//           disabled: false,
//           required: false,
//         },
//       },
//       {
//         type: 'signature',
//         label: 'ç­¾å',
//         icon: 'signature',
//         key: '',
//         id: '',
//         options: {
//           required: false,
//           isShowLabel: true,
//           labelWidth: 100,
//           defaultValue: '',
//           penColor: 'rgb(0, 0, 0)',
//           action: '',
//           disabled: false,
//         },
//       },
//     ],
//   },
//   {
//     name: 'å®¹å™¨',
//     id: 'container',
//     children: [
//       {
//         type: 'grid',
//         label: 'grid',
//         icon: 'grid',
//         id: '',
//         columns: [
//           {
//             id: '', //
//             options: {
//               span: 12,
//               offset: 0,
//               pull: 0,
//               push: 0,
//             },
//             type: 'col',
//             list: [],
//           },
//         ],
//         options: {
//           gutter: 0,
//           justify: 'start',
//           align: 'top',
//         },
//       },
//       {
//         type: 'table',
//         label: 'è¡¨æ ¼å¸ƒå±€',
//         icon: 'tableStokeP2',
//         id: '',
//         rows: [
//           {
//             type: 'tr',
//             columns: [
//               {
//                 type: 'td',
//                 options: {
//                   colspan: 1,
//                   rowspan: 1,
//                   isMerged: false,
//                 },
//                 list: [],
//                 style: {},
//               },
//               // {
//               //   type: 'td',
//               //   options: {
//               //     colspan: 1,
//               //     rowspan: 1,
//               //     isMerged: false
//               //   },
//               //   list: [],
//               //   style: {}
//               // }
//             ],
//           },
//           // {
//           //   type: 'tr',
//           //   columns: [
//           //     {
//           //       type: 'td',
//           //       options: {
//           //         colspan: 1,
//           //         rowspan: 1,
//           //         isMerged: false
//           //       },
//           //       list: [],
//           //       style: {}
//           //     },
//           //     {
//           //       type: 'td',
//           //       options: {
//           //         colspan: 1,
//           //         rowspan: 1,
//           //         isMerged: false
//           //       },
//           //       list: [],
//           //       style: {}
//           //     }
//           //   ]
//           // }
//         ],
//         options: {
//           width: 100,
//           widthType: '%',
//         },
//       },
//       {
//         type: 'tabs',
//         label: 'æ ‡ç­¾é¡µ',
//         icon: 'label',
//         id: '',
//         columns: [],
//         options: {
//           type: '',
//           tabPosition: 'top',
//           align: 'top',
//           hidden: false,
//         },
//       },
//       {
//         type: 'collapse',
//         label: 'æŠ˜å é¢æ¿',
//         icon: 'collapse',
//         id: '',
//         columns: [],
//         options: {
//           defaultValue: [],
//           accordion: false,
//         },
//       },
//       {
//         type: 'divider',
//         label: 'åˆ†å‰²çº¿',
//         icon: 'divider',
//         key: '',
//         id: '',
//         options: {
//           contentPosition: 'center',
//           filterable: true,
//           defaultValue: 'divider',
//           labelWidth: 100,
//           labelHidden: true,
//           required: false,
//         },
//       },
//       // {
//       //   type: 'subform',
//       //   label: 'å­è¡¨å•',
//       //   icon: 'subform',
//       //   id: '',
//       //   list: [
//       //     []
//       //   ],
//       //   options: {
//       //     defaultValue: [],
//       //     isShowLabel: true,
//       //     required: false,
//       //     disabled: false
//       //   }
//       // }
//     ],
//   },
// ]


 {
          type: 'rate',
          label: 'è¯„åˆ†',
          icon: 'rating',
          key: '',
          id: '',
          options: {
            max: 5,
            allowHalf: false,
            defaultValue: 0,
            labelWidth: 100,
            isShowLabel: true,
            disabled: false,
          },
        },
        // {
        //   type: 'color',
        //   label: 'é¢œè‰²',
        //   icon: 'color-filling',
        //   key: '',
        //   id: '',
        //   options: {
        //     showAlpha: false,
        //     defaultValue: '',
        //     placeholder: '',
        //     labelWidth: 100,
        //     isShowLabel: true,
        //     required: false,
        //     requiredHint: '',
        //     validation: '',
        //     validationHint: '',
        //     minlength: null,
        //     maxlength: null
        //   }
        // },
        {
          type: 'switch',
          label: 'å¼€å…³',
          icon: 'switch',
          key: '',
          id: '',
          options: {
            defaultValue: true,
            labelWidth: 100,
            isShowLabel: true,
            disabled: false,
          },
        },
        {
          type: 'slider',
          label: 'æ»‘å—',
          icon: 'slider',
          key: '',
          id: '',
          options: {
            min: 0,
            max: 100,
            step: 1,
            defaultValue: 0,
            placeholder: '',
            labelWidth: 100,
            isShowLabel: true,
            required: false,
            disabled: false,
          },
        },
        {
          type: 'html',
          label: 'å¯Œæ–‡æœ¬ç¼–è¾‘å™¨',
          icon: 'html',
          key: '',
          id: '',
          options: {
            defaultValue: '',
            placeholder: '',
            action: '',
            size: 1,
            labelWidth: 100,
            isShowLabel: true,
            required: false,
            disabled: false,
          },
        },

         let allT2 = [
      {
        label: 'é¦–é¡µ',
        value: 'home',
        tableName: 'home',
      }, {
        label: 'ç™»å½•',
        value: 'login',
        tableName: 'login',//
      }
    ]

     // console.log(_r2, '_r2') //
    // let _r=ins.getCellRelativeRect(addR.col, addR.row)
    // console.log(_r,'_r')//
    // console.log(rect, 'testRect') ////
    // let _rect = {
    //   bounds: {
    //     x1: 930,
    //     y1: 70,
    //     x2: 1030,
    //     y2: 100,
    //   },
    //   bottom: 100,
    //   height: 30,
    //   left: 930,//
    //   right: 1030,
    //   top: 70,
    //   width: 100,
    // }


     // let getFlatParent = (row, arr = []) => {
    //   let pIndex = row['_parentIndex']
    //   if (pIndex == null) {
    //     arr.push(row)
    //   } else {
    //     let pRow = dMap[pIndex]
    //     getFlatParent(pRow, arr) //
    //   }
    //   return arr //
    // }

    generateEditPageLayout(row) {
    let oldFields = row.fields //
    let dEnF = oldFields
      .filter((row) => {
        //
        return row.type == 'entity' && row?.options?.tableType == 'detail'
      }) //
      .map((row) => {
        let _row = _.cloneDeep(row)
        return _row
      })
    let dEnF2 = dEnF.map((row) => {
      let fIns = row.id
      if (fIns == null) {
        row.id = this.uuid()
        fIns = row.id //
      }
      let obj = {
        ...this.createNodeIdKey('tabsCol'),
        label: 'Tab 1',
        list: [
          {
            ...this.createNodeIdKey('inline'),
            style: {},
            columns: [fIns],
          },
        ],
        style: {},
        options: {},
        innerId: fIns,
      }
      return obj
    })
    let fId = this.uuid()
    let fField = {
      id: fId,
      key: `dform_${fId}`,
      type: 'dform',
      options: {},
    }
    let detailLayout = {
      id: 'f6qNjbhckRKxcgbyzimpA',
      key: 'inline_f6qNjbhckRKxcgbyzimpA',
      type: 'inline',
      columns: [
        {
          id: 'NFcD7gLoRJ0UQJcRGAP1I',
          key: 'grid_NFcD7gLoRJ0UQJcRGAP1I',
          type: 'grid',
          options: {
            gutter: 0,
            justify: 'start',
            align: 'top',
          },
          style: {
            width: '100%',
          },
          columns: [
            {
              id: '0Ifq8JGCuqIYsIEJEcOE4',
              key: 'col_0Ifq8JGCuqIYsIEJEcOE4',
              type: 'col',
              list: [
                {
                  type: 'inline',
                  columns: [
                    {
                      id: 'mJp7crngSZBQiiMhqIJ1N',
                      key: 'tabs_mJp7crngSZBQiiMhqIJ1N',
                      icon: 'label',
                      type: 'tabs',
                      label: 'æ ‡ç­¾é¡µ',
                      style: {
                        width: '100%',
                      },
                      columns: [...dEnF2],
                      options: {
                        type: '',
                        align: 'top',
                        hidden: false,
                        tabPosition: 'top',
                        defaultValue: dEnF2[0]?.id, //
                      },
                    },
                  ],
                },
              ],
              options: {
                span: 24, //
                offset: 0,
                push: 0,
                pull: 0,
                style: {},
              },
            },
          ],
        },
      ],
    }
    if (dEnF2.length == 0) {
      detailLayout = null
    }
    const editLayout = {
      layout: {
        pc: [
          {
            id: 'yWTdNJ14jZVhBpu1kiSHB',
            key: 'inline_yWTdNJ14jZVhBpu1kiSHB',
            type: 'inline',
            columns: [
              {
                id: 'LFhDBVgwITtxF-8qbD1Sk',
                key: 'grid_LFhDBVgwITtxF-8qbD1Sk',
                type: 'grid',
                options: {
                  gutter: 0,
                  justify: 'start',
                  align: 'top',
                },
                style: {
                  width: '100%',
                },
                columns: [
                  {
                    id: 'S9B-oByUkfc2LoAISnY3H',
                    key: 'col_S9B-oByUkfc2LoAISnY3H',
                    type: 'col',
                    list: [
                      {
                        type: 'inline',
                        columns: [
                          {
                            type: 'tabs',
                            label: 'æ ‡ç­¾é¡µ',
                            icon: 'label',
                            id: 'nWcXBEOYl2M980Eg8OyJj',
                            columns: [
                              {
                                id: '_yNuSux3VBlbqnoWdXvYb',
                                type: 'tabsCol',
                                label: 'Tab 1',
                                list: [
                                  {
                                    type: 'inline',
                                    columns: [fId],
                                    style: {},
                                    id: 'n5BkoBMEBOeokN55IDx-M',
                                    key: 'inline_n5BkoBMEBOeokN55IDx-M',
                                  },
                                ],
                                style: {},
                                options: {},
                                key: 'tabsCol__yNuSux3VBlbqnoWdXvYb',
                              },
                            ],
                            options: {
                              type: '',
                              tabPosition: 'top',
                              align: 'top',
                              hidden: false,
                              defaultValue: '_yNuSux3VBlbqnoWdXvYb',
                            },
                            style: {
                              width: '100%',
                            },
                            key: 'tabs_nWcXBEOYl2M980Eg8OyJj',
                          },
                        ],
                      },
                    ],
                    options: {
                      span: 24,
                      offset: 0,
                      push: 0,
                      pull: 0,
                      style: {},
                    },
                  },
                ],
              },
            ],
          },
        ],
        mobile: [
          // {
          //   type: 'inline',
          //   columns: ['61fuq2KoXI-LXZ-d_ep95'],
          // },
          // {
          //   type: 'inline',
          //   columns: ['KRg51faFSk3H2piRFbrQg'],
          // },
        ],
      },
      data: {},
      config: {
        isSync: true,
        pc: {
          size: 'default',
          labelPosition: 'left',
          completeButton: {
            text: 'æäº¤',
            color: '',
            backgroundColor: '',
          },
        },
        mobile: {
          labelPosition: 'left',
          completeButton: {
            text: 'æäº¤',
            color: '',
            backgroundColor: '',
          },
        },
        id: '3H1haKaSUMIocpYwWqD4z',
        type: 'root',
      },
      fields: [fField, ...dEnF],
      logic: {},
    }
    if (detailLayout != null) {
      editLayout.layout.pc.push(detailLayout) //
    }
    return editLayout //
  }

  if (row == null) {
      let _data1 = await http.find('entity', { tableName: name })
      let _row = _data1[0]
      let row2 = this.generateEditPageLayout(_row)
      return row2 //
      //è½¬æ¢
    }

     // let _cols1 = _cols.map((item) => {
    //   return {
    //     value: item.field,
    //     label: item.title || item.field,
    //   }
    // })
    // columnSelect[tableName] = _cols1 //
    // columnSelect[_key] = true //
 {
        label: 'å®½åº¦',
        field: 'width',
        type: 'string',
        tabTitle: titles[0],
      },

    //æ–°å¢ä¸€è¡Œæ•°æ®
        // let tableName = page.getTableName() //
        // let tRef: Table = page.getRef(tableName) //
        // if (tRef == null) {
        //   return
        // }
        // tRef.addRows(1) //


           if (disabledDefaultFn == 'scanDisabled') {
          }


            {
            label: 'æ–°å¢çŠ¶æ€ç¦ç”¨',
            value: 'addDisabled',
          },


           pageDesign.use('getTableData', async (context, next) => {
      let fArg = context.args[0]
      let instance: PageDesign = context.instance
      let query = fArg.query
      let tableName = fArg.tableName
      let _tName = instance.getTableName()
      let _d1 = {}
      if (tableName == _tName) {
        let _d = instance.getSearchBindData() //
        let _dn = Object.entries(_d)
        if (_dn.length > 0 && _dn.map((d) => d[1]).some((d) => d != null)) {
          _d1 = _d
        }
      } //
      let searchWhere = instance.getSearchWhere(_d1) //
      let result = _.merge({}, query, searchWhere)
      fArg.query = result //
      instance.setCurrentLoading(true)
      //è·å–å…¨å±€çš„æŸ¥è¯¢æ¡ä»¶
      await next().finally(() => {
        setTimeout(() => {
          instance.setCurrentLoading(false) //
        }, 200)
      }) //
      instance.setCurrentView() //
    })

     // {
        //   label: 'ä¿å­˜',
        //   fn: async (config) => {
        //     let p: Table = config.parent
        //     let d = p.getFlatTreeData()
        //     let changeData = d.filter((item) => {
        //       let _rowState = item['_rowState']
        //       return _rowState == 'change'
        //     })
        //     // console.log('sfsdss', changeData)//
        //     await this.getHttp().patch('navs', changeData) //
        //     this.confirmMessage('æ›´æ–°èœå•æˆåŠŸ') ////
        //     this.clearCacheValue('getMenuData') //
        //     await this.getMenuData() //
        //   },
        // },

        ||
              _.get(
                state.fieldsLogicState.get(element),
                'visible',
                undefined,
              ) !== 0


                // let _slots = _attrs['_slots']
      // let _obj = null
      // if (Array.isArray(_slots)) {
      //   _obj = _slots.reduce((res, cur) => {
      //     let _item = slots[cur]
      //     if (_item) {
      //       res[cur] = _item
      //     }
      //     return res
      //   }, {})
      // } ////

      onBeforeUnmount(() => {
      const index = _.findIndex(state.validateStates, {
        data: { id: props.data.id },
      })
      if (index !== -1) {
        state.validateStates.splice(index, 1)
      }
    })